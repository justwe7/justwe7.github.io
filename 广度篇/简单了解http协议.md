- [什么是http协议](#%E4%BB%80%E4%B9%88%E6%98%AFhttp%E5%8D%8F%E8%AE%AE)
  - [通过请求和响应的交换达成通信](#%E9%80%9A%E8%BF%87%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E7%9A%84%E4%BA%A4%E6%8D%A2%E8%BE%BE%E6%88%90%E9%80%9A%E4%BF%A1)
  - [HTTP是不保存状态协议(无状态协议)](#HTTP%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE)
  - [使用URI定位资源](#%E4%BD%BF%E7%94%A8URI%E5%AE%9A%E4%BD%8D%E8%B5%84%E6%BA%90)
  - [告知服务端意图的http方法(method)](#%E5%91%8A%E7%9F%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%84%8F%E5%9B%BE%E7%9A%84http%E6%96%B9%E6%B3%95method)
    - [GET-获取资源](#GET-%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90)
    - [POST-传输实体主体](#POST-%E4%BC%A0%E8%BE%93%E5%AE%9E%E4%BD%93%E4%B8%BB%E4%BD%93)
    - [PUT-传输文件](#PUT-%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6)
    - [DELETE-删除文件](#DELETE-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6)
    - [HEAD-获得报文首部](#HEAD-%E8%8E%B7%E5%BE%97%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8)
    - [OPTION-询问支持的方法](#OPTION-%E8%AF%A2%E9%97%AE%E6%94%AF%E6%8C%81%E7%9A%84%E6%96%B9%E6%B3%95)
    - [TRACE-追踪路径](#TRACE-%E8%BF%BD%E8%B8%AA%E8%B7%AF%E5%BE%84)
    - [CONNECT-要求用隧道协议连接代理](#CONNECT-%E8%A6%81%E6%B1%82%E7%94%A8%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE%E8%BF%9E%E6%8E%A5%E4%BB%A3%E7%90%86)
  - [持久连接节省通信量(http/1.1之后的优化)](#%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5%E8%8A%82%E7%9C%81%E9%80%9A%E4%BF%A1%E9%87%8Fhttp11%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BC%98%E5%8C%96)
    - [持久连接](#%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5)
    - [管线化](#%E7%AE%A1%E7%BA%BF%E5%8C%96)
  - [使用cookie进行状态管理(如登陆验证等应用)](#%E4%BD%BF%E7%94%A8cookie%E8%BF%9B%E8%A1%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%A6%82%E7%99%BB%E9%99%86%E9%AA%8C%E8%AF%81%E7%AD%89%E5%BA%94%E7%94%A8)

# 什么是http协议
- 处于TCP/IP协议族，用于客户端与服务器之间的通信。发起请求的一端称为客户端，提供响应的成为服务端。(按实际情况，两台计算机作为客户端和服务器端的角色有 可能会互换。但就仅从一条通信路线来说，服务器端和客户端的角色是 确定的，而用HTTP协议能够明确区分哪端是客户端，哪端是服务器端。)
  
## 通过请求和响应的交换达成通信
肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。  
- 请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字 段和内容实体构成的。
- 响应报文基本上由协议版本、状态码（表示请求成功或失败的数字 代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。

## HTTP是不保存状态协议(无状态协议)
也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。(客户端服务器都不保存之前发送过的请求)。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成 如此简单的。为了能够保持状态，引入的cookie技术。

## 使用URI定位资源
当客户端请求访问资源而发送请求时，URI 需要将作为请求报文中 的请求 URI 包含在内。指定请求URI的方式有：
- 完整的uri,http://17qu.top/api/article
- 首部字段(request)Host中指明域名或者IP(Host: 17qu.top)

## 告知服务端意图的http方法(method)
### GET-获取资源
如果请求的资源是文本，那就保持原样返回
### POST-传输实体主体  
POST 的主要目的并不是获取响应的主体内容，是为了提交数据给服务端。注意**GET 方法也可以传输实体的主体**
### PUT-传输文件
就像 FTP 协议的文件上传一样，要求在 请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。 但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可 以上传文件,存在安全性问题，因此一般的Web网站不使用该方法。若 配合Web应用程序的验证机制，或架构设计采用REST（Representational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使 用 PUT 方法。
### DELETE-删除文件
与PUT相反
### HEAD-获得报文首部
和GET一样，不返回报文主体(只返回response)。用于确认 URI的有效性及资源更新的日期时间等。
### OPTION-询问支持的方法
获取服务器支持的HTTP请求方法；用来检查服务器的性能
规范要求：对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。那么, 什么情况下请求会变成preflighted request呢: 
1. 请求方法不是GET/HEAD/POST
2. POST请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain
3. 请求设置了自定义的header字段
### TRACE-追踪路径 
让 Web 服务器端将之前的请求通信环回给客户端的 方法。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个 服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最 后接收到请求的服务器端则返回状态码 200 OK 的响应。 容易引发 XST （Cross-Site Tracing，跨站追踪）攻击
### CONNECT-要求用隧道协议连接代理 
CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道 协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接 层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。 

扩展了解：跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。


## 持久连接节省通信量(http/1.1之后的优化)
HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。图片、接口、懒加载内容过多时，会造成过多的开销。
### 持久连接
持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。也称为 HTTP keep-alive 或 HTTP connection reuse。在 HTTP/1.1 中，所有的连接默认都是持久连接
### 管线化
从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等 待响应了。

## 使用cookie进行状态管理(如登陆验证等应用)
HTTP是无状态协议，可以理解为0秒钟记忆的🐟，进行一次TCP连接之后不会保存当前状态，无法根据之前的状态进行本次的请求处理。  
保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。
Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。