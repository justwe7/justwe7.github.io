(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{223:function(t,E,a){"use strict";a.r(E);var r=a(0),e=Object(r.a)({},(function(){var t=this,E=t.$createElement,a=t._self._c||E;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("ul",[a("li",[a("a",{attrs:{href:"#%E4%BB%80%E4%B9%88%E6%98%AFhttp%E5%8D%8F%E8%AE%AE"}},[t._v("什么是http协议")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#%E9%80%9A%E8%BF%87%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E7%9A%84%E4%BA%A4%E6%8D%A2%E8%BE%BE%E6%88%90%E9%80%9A%E4%BF%A1"}},[t._v("通过请求和响应的交换达成通信")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#HTTP%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE"}},[t._v("HTTP是不保存状态协议(无状态协议)")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#%E4%BD%BF%E7%94%A8URI%E5%AE%9A%E4%BD%8D%E8%B5%84%E6%BA%90"}},[t._v("使用URI定位资源")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#%E5%91%8A%E7%9F%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%84%8F%E5%9B%BE%E7%9A%84http%E6%96%B9%E6%B3%95method"}},[t._v("告知服务端意图的http方法(method)")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#GET-%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90"}},[t._v("GET-获取资源")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#POST-%E4%BC%A0%E8%BE%93%E5%AE%9E%E4%BD%93%E4%B8%BB%E4%BD%93"}},[t._v("POST-传输实体主体")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#PUT-%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6"}},[t._v("PUT-传输文件")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#DELETE-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"}},[t._v("DELETE-删除文件")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#HEAD-%E8%8E%B7%E5%BE%97%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8"}},[t._v("HEAD-获得报文首部")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#OPTION-%E8%AF%A2%E9%97%AE%E6%94%AF%E6%8C%81%E7%9A%84%E6%96%B9%E6%B3%95"}},[t._v("OPTION-询问支持的方法")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#TRACE-%E8%BF%BD%E8%B8%AA%E8%B7%AF%E5%BE%84"}},[t._v("TRACE-追踪路径")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#CONNECT-%E8%A6%81%E6%B1%82%E7%94%A8%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE%E8%BF%9E%E6%8E%A5%E4%BB%A3%E7%90%86"}},[t._v("CONNECT-要求用隧道协议连接代理")])])])]),t._v(" "),a("li",[a("a",{attrs:{href:"#%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5%E8%8A%82%E7%9C%81%E9%80%9A%E4%BF%A1%E9%87%8Fhttp11%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BC%98%E5%8C%96"}},[t._v("持久连接节省通信量(http/1.1之后的优化)")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5"}},[t._v("持久连接")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#%E7%AE%A1%E7%BA%BF%E5%8C%96"}},[t._v("管线化")])])])]),t._v(" "),a("li",[a("a",{attrs:{href:"#%E4%BD%BF%E7%94%A8cookie%E8%BF%9B%E8%A1%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%A6%82%E7%99%BB%E9%99%86%E9%AA%8C%E8%AF%81%E7%AD%89%E5%BA%94%E7%94%A8"}},[t._v("使用cookie进行状态管理(如登陆验证等应用)")])])])])]),t._v(" "),a("h1",{attrs:{id:"什么是http协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是http协议"}},[t._v("#")]),t._v(" 什么是http协议")]),t._v(" "),a("ul",[a("li",[t._v("处于TCP/IP协议族，用于客户端与服务器之间的通信。发起请求的一端称为客户端，提供响应的成为服务端。(按实际情况，两台计算机作为客户端和服务器端的角色有 可能会互换。但就仅从一条通信路线来说，服务器端和客户端的角色是 确定的，而用HTTP协议能够明确区分哪端是客户端，哪端是服务器端。)")])]),t._v(" "),a("h2",{attrs:{id:"通过请求和响应的交换达成通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过请求和响应的交换达成通信"}},[t._v("#")]),t._v(" 通过请求和响应的交换达成通信")]),t._v(" "),a("p",[t._v("肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。")]),t._v(" "),a("ul",[a("li",[t._v("请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字 段和内容实体构成的。")]),t._v(" "),a("li",[t._v("响应报文基本上由协议版本、状态码（表示请求成功或失败的数字 代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。")])]),t._v(" "),a("h2",{attrs:{id:"http是不保存状态协议-无状态协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http是不保存状态协议-无状态协议"}},[t._v("#")]),t._v(" HTTP是不保存状态协议(无状态协议)")]),t._v(" "),a("p",[t._v("也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。(客户端服务器都不保存之前发送过的请求)。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成 如此简单的。为了能够保持状态，引入的cookie技术。")]),t._v(" "),a("h2",{attrs:{id:"使用uri定位资源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用uri定位资源"}},[t._v("#")]),t._v(" 使用URI定位资源")]),t._v(" "),a("p",[t._v("当客户端请求访问资源而发送请求时，URI 需要将作为请求报文中 的请求 URI 包含在内。指定请求URI的方式有：")]),t._v(" "),a("ul",[a("li",[t._v("完整的uri,如：http://lihx.top/api/article(http://lihx.top 域)(/api/article 接口)")]),t._v(" "),a("li",[t._v("首部字段(request)Host中指明域名或者IP(Host: lihx.top)")])]),t._v(" "),a("h2",{attrs:{id:"告知服务端意图的http方法-method"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#告知服务端意图的http方法-method"}},[t._v("#")]),t._v(" 告知服务端意图的http方法(method)")]),t._v(" "),a("h3",{attrs:{id:"get-获取资源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-获取资源"}},[t._v("#")]),t._v(" GET-获取资源")]),t._v(" "),a("p",[t._v("如果请求的资源是文本，那就保持原样返回")]),t._v(" "),a("h3",{attrs:{id:"post-传输实体主体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#post-传输实体主体"}},[t._v("#")]),t._v(" POST-传输实体主体")]),t._v(" "),a("p",[t._v("POST 的主要目的并不是获取响应的主体内容，是为了提交数据给服务端。注意"),a("strong",[t._v("GET 方法也可以传输实体的主体")])]),t._v(" "),a("h3",{attrs:{id:"put-传输文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#put-传输文件"}},[t._v("#")]),t._v(" PUT-传输文件")]),t._v(" "),a("p",[t._v("就像 FTP 协议的文件上传一样，要求在 请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。 但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可 以上传文件,存在安全性问题，因此一般的Web网站不使用该方法。若 配合Web应用程序的验证机制，或架构设计采用REST（Representational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使 用 PUT 方法。")]),t._v(" "),a("h3",{attrs:{id:"delete-删除文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#delete-删除文件"}},[t._v("#")]),t._v(" DELETE-删除文件")]),t._v(" "),a("p",[t._v("与PUT相反")]),t._v(" "),a("h3",{attrs:{id:"head-获得报文首部"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#head-获得报文首部"}},[t._v("#")]),t._v(" HEAD-获得报文首部")]),t._v(" "),a("p",[t._v("和GET一样，不返回报文主体(只返回response)。用于确认 URI的有效性及资源更新的日期时间等。")]),t._v(" "),a("h3",{attrs:{id:"option-询问支持的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#option-询问支持的方法"}},[t._v("#")]),t._v(" OPTION-询问支持的方法")]),t._v(" "),a("p",[t._v("获取服务器支持的HTTP请求方法；用来检查服务器的性能\n规范要求：对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。那么, 什么情况下请求会变成preflighted request呢:")]),t._v(" "),a("ol",[a("li",[t._v("请求方法不是GET/HEAD/POST")]),t._v(" "),a("li",[t._v("POST请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain")]),t._v(" "),a("li",[t._v("请求设置了自定义的header字段")])]),t._v(" "),a("h3",{attrs:{id:"trace-追踪路径"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#trace-追踪路径"}},[t._v("#")]),t._v(" TRACE-追踪路径")]),t._v(" "),a("p",[t._v("让 Web 服务器端将之前的请求通信环回给客户端的 方法。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个 服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最 后接收到请求的服务器端则返回状态码 200 OK 的响应。 容易引发 XST （Cross-Site Tracing，跨站追踪）攻击")]),t._v(" "),a("h3",{attrs:{id:"connect-要求用隧道协议连接代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#connect-要求用隧道协议连接代理"}},[t._v("#")]),t._v(" CONNECT-要求用隧道协议连接代理")]),t._v(" "),a("p",[t._v("CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道 协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接 层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。")]),t._v(" "),a("p",[t._v("扩展了解：跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。")]),t._v(" "),a("h2",{attrs:{id:"持久连接节省通信量-http-1-1之后的优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持久连接节省通信量-http-1-1之后的优化"}},[t._v("#")]),t._v(" 持久连接节省通信量(http/1.1之后的优化)")]),t._v(" "),a("p",[t._v("HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。图片、接口、懒加载内容过多时，会造成过多的开销。")]),t._v(" "),a("h3",{attrs:{id:"持久连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持久连接"}},[t._v("#")]),t._v(" 持久连接")]),t._v(" "),a("p",[t._v("持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。也称为 HTTP keep-alive 或 HTTP connection reuse。在 HTTP/1.1 中，所有的连接默认都是持久连接")]),t._v(" "),a("h3",{attrs:{id:"管线化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#管线化"}},[t._v("#")]),t._v(" 管线化")]),t._v(" "),a("p",[t._v("从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等 待响应了。")]),t._v(" "),a("h2",{attrs:{id:"使用cookie进行状态管理-如登陆验证等应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用cookie进行状态管理-如登陆验证等应用"}},[t._v("#")]),t._v(" 使用cookie进行状态管理(如登陆验证等应用)")]),t._v(" "),a("p",[t._v("HTTP是无状态协议，可以理解为0秒钟记忆的🐟，"),a("strong",[t._v("进行一次TCP连接之后不会保存当前状态，无法根据之前的状态进行本次的请求处理")]),t._v("。无状态特征的好处是可以减少服务器的性能消耗，能够更快的响应。\n保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。\nCookie 会根据从服务器端发送的响应报文内的一个叫做"),a("strong",[t._v("Set-Cookie的首部字段信息")]),t._v("，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。")])])}),[],!1,null,null,null);E.default=e.exports}}]);