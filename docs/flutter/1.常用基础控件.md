## 文本控件
### Text
用于显示简单样式文本:
```dart
Text("Hello world")
// 添加属性
Text('你好', textAlign: TextAlign.left, )
```

| API | 属性 | 描述 |
| ---- | ---- | ---- |
| textAlign | TextAlign.left | 对齐方式，对齐的参考系是Text widget 本身，如果宽度本身撑不满一行没有效果 |
| maxLines: 2,<br>overflow: TextOverflow.ellipsis, |  | 最大行数及截断方式 |
| textScaleFactor | init | 理解为字体大小的em值，默认为1em。该属性的默认值可以通过MediaQueryData.textScaleFactor |
| style | TextStyle | 文本样式 |
注意： `textScaleFactor` 属性在Flutter的未来版本中已被弃用，原因是为了准备支持更复杂的非线性文本缩放功能。作为替代，应使用新引入的 `textScaler` 属性:
```dart
textScaler: TextScaler.linear(2),
// 等同于
textScaleFactor: 2,
```
##### TextStyle
设置字体:
```dart
Text("Hello world",
  style: TextStyle(
    color: Colors.blue,
    fontSize: 18.0,
    height: 1.2,  
    fontFamily: "Courier",
    background: Paint()..color=Colors.yellow,
    decoration:TextDecoration.underline,
    decorationStyle: TextDecorationStyle.dashed
  ),
);
```

| API             | 属性                         | 描述                                                                                  |
| --------------- | ---------------------------- | ------------------------------------------------------------------------------------- |
| fontSize                | 16.0                             | `fontSize`可以精确指定字体大小，而`textScaleFactor`只能通过缩放比例来控制                                                                                      |
| height          |                              | 该属性用于指定行高，但它并不是一个绝对值，而是一个因子，具体的行高等于fontSize*height |
| fontFamily      |                              |                                                                                       |
| color           | Colors.red                   | 字体颜色                                                                              |
| background      | Paint()..color=Colors.yellow | 背景色                                                                                |
| decoration      | TextDecoration.underline     | 字体修饰                                                                              |
| decorationStyle | TextDecorationStyle.dashed   | 修饰样式                                                                              |

在Dart语言中，`..` 语法称为级联操作符（cascade operator）：
```dart
var paint = Paint(); 
paint.color = Colors.yellow;
// 等同于
var paint = Paint()..color = Colors.yellow;
```

### TextSpan
Text 的所有文本内容只能按同一种样式，如果我们需要对一个 Text 内容的不同部分按照不同的样式显示，这时就可以使用`TextSpan`，比如html中段落需要超链样式的协议就比较方便:
```dart
Text.rich(TextSpan(
  children: [
      TextSpan(
        text: "Home: "
      ),
      TextSpan(
      text: "https://flutterchina.club",
      style: TextStyle(color: Colors.blue),
      recognizer: TapGestureRecognizer()..onTap = () {
        // 这里可以使用url_launcher包来打开链接
        print('Open the URL');
      },
    ),
  ]
)),
```
![](../../static/docs/Pasted%20image%2020240129180308.jpeg)
在`TextSpan`中，可以使用`children`属性来嵌套更多的`TextSpan`对象，以此创建一个富文本布局。但`TextSpan`只能包含其他`TextSpan`对象，不能包含`Text`或其他类型的widget。

### DefaultTextStyle
如果在 Widget 树的某一个节点处设置一个默认的文本样式，那么该节点的子树中所有文本都会默认使用这个样式，而`DefaultTextStyle`正是用于设置默认文本样式的：
```dart
DefaultTextStyle(
  //1.设置文本默认样式  
  style: TextStyle(
    color: Colors.red,
    fontSize: 20.0,
  ),
  textAlign: TextAlign.start,
  child: Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: <Widget>[
      Text("hello world"),
      Text("I am Jack"),
      Text("I am Jack",
        style: TextStyle(
          inherit: false, //2.不继承默认样式
          color: Colors.grey
        ),
      ),
    ],
  ),
),
```

## 按钮控件
Material 组件库中提供了多种按钮组件如`ElevatedButton`、`TextButton`、`OutlinedButton`等，它们都是直接或间接对`RawMaterialButton`组件的包装定制，按下时都会有“水波动画”（又称“涟漪动画”，就是点击时按钮上会出现水波扩散的动画）
现在(2024年01月)默认引入的material的版本为v3，所以默认样式与一些教程中图片展示有差异：[flutter Material3风格Button、AppBar，Material3与Material2简单对比 - 掘金](https://juejin.cn/post/7240020551404896293)

### ElevatedButton
通过style自定义按钮的样式，默认有阴影和灰色背景
```dart
ElevatedButton(
  child: Text("按钮"),
  // style: ElevatedButton.styleFrom(
  //   foregroundColor: Colors.white, // 按下时的前景色
  //   backgroundColor: Colors.blue,
  // ),
  onPressed: () {},
),
```
![](../../static/docs/Pasted%20image%2020240130100336.jpeg)

### TextButton
文本按钮，默认没有阴影和背景色，按下时有涟漪背景色
```dart
TextButton(
  child: Text("按钮"),
  onPressed: () {},
),
```
![](../../static/docs/iShot_2024-01-30_10.12.00.gif)
### OutlinedButton
带边框的按钮，默认没有阴影和背景色，按下有涟漪背景色
```dart
OutlinedButton(
  child: Text("按钮"),
  onPressed: () {},
),
```
![](../../static/docs/Pasted%20image%2020240130101730.jpeg)

### IconButton
不包括文字，默认没有背景，点击后会出现背景
```dart
IconButton(
  icon: Icon(Icons.add),
  onPressed: () {},
),
```
![](../../static/docs/Pasted%20image%2020240130102025.jpeg)

### 带图标的按钮
`ElevatedButton`、`TextButton`、`OutlinedButton`都有一个`icon` 构造函数:
```dart
ElevatedButton.icon(
  icon: Icon(Icons.send),
  label: Text("发送"),
  onPressed: () {},
),
OutlinedButton.icon(
  icon: Icon(Icons.add),
  label: Text("添加"),
  onPressed: () {},
),
TextButton.icon(
  icon: Icon(Icons.info),
  label: Text("详情"),
  onPressed: () {},
),
```
![](../../static/docs/Pasted%20image%2020240130102229.jpeg)

## 图片及ICON
通过`Image`组件来加载并显示图片，`Image`的数据源可以是asset、文件、内存以及网络。
`ImageProvider` 是一个抽象类，主要定义了图片数据获取的接口`load()`，从不同的数据源获取图片需要实现不同的`ImageProvider` ，如`AssetImage`是实现了从Asset中加载图片的 ImageProvider，而`NetworkImage` 实现了从网络加载图片的 ImageProvider。
### 本地图片
1. 项目根目录创建`images目录`，并将图片 avatar.png 拷贝到该目录
2. 在`pubspec.yaml`中的`flutter`部分添加目录，也可以指定文件名称:
![](../../static/docs/Pasted%20image%2020240130103455.jpeg)
3. 代码中加载图片：
```dart
Image.asset('images/avatar.png',
  width: 300.0,
),
// 或者
Image(
  image: AssetImage("images/avatar.png"),
  width: 100.0
);
```

### 远端
直接抛链接就好了
```dart
Image.network("https://s2.loli.net/2024/01/03/FO8skIcnBjYvuiN.png",
  height: 100.0,
),
// 或者
Image(
  image: NetworkImage("https://s2.loli.net/2024/01/03/FO8skIcnBjYvuiN.png"),
  height: 100.0,
),
```

### 远端图片资源(圆形头像)
```dart
const CircleAvatar(
  backgroundImage: NetworkImage(
      'https://s2.loli.net/2024/01/03/FO8skIcnBjYvuiN.png',
  ),
  radius: 2
  0,
),
```
![](../../static/docs/Pasted%20image%2020240130110105.jpeg)
### 占位图
如果考虑用户弱网或者资源过大的情况，用本地图片实现占位图：
```dart
const FadeInImage(
  placeholder: AssetImage('images/avatar.png'),
  image: NetworkImage('https://s2.loli.net/2024/01/28/BTOFjZbVe6aNnAk.png')
),
```
![](../../static/docs/iShot_2024-01-30_10.58.33.gif)

### Image参数
```dart
const Image({
  ...
  this.width, //图片的宽
  this.height, //图片高度
  this.color, //图片的混合色值
  this.colorBlendMode, //混合模式
  this.fit,//缩放模式
  this.alignment = Alignment.center, //对齐方式
  this.repeat = ImageRepeat.noRepeat, //重复方式
  ...
})
```

| 属性 | 值 | 描述 |
| ---- | ---- | ---- |
| width / height | 100.0 | 用于设置图片的宽、高，当不指定宽高时，图片会根据当前父容器的限制，尽可能的显示其原始大小，如果只设置`width`、`height`的其中一个，那么另一个属性默认会按比例缩放，但可以通过`fit`属性来指定适应规则 |
| fit | BoxFit.contain | 适应模式是在BoxFit中定义，它是一个枚举类型 |
| repeat | ImageRepeat.repeat | 当图片本身大小小于显示空间时，指定图片的重复规则 |
**Fit效果：**
![](../../static/docs/Pasted%20image%2020240130110803.jpeg)

### Icon
[3.3 图片及ICON | 《Flutter实战·第二版》](https://book.flutterchina.club/chapter3/img_and_icon.html#_3-3-2-icon)
Flutter默认包含了一套Material Design的字体图标，在`pubspec.yaml`文件中的配置:
```dart
flutter:
  uses-material-design: true
```
使用：
```dart
String icons = "";
// accessible: 0xe03e
icons += "\uE03e";
// error:  0xe237
icons += " \uE237";
// fingerprint: 0xe287
icons += " \uE287";

Text(
  icons,
  style: TextStyle(
    fontFamily: "MaterialIcons",
    fontSize: 24.0,
    color: Colors.green,
  ),
);
```

## Checkbox、Switch
本身不会保存当前选中状态，选中状态都是由父组件来管理的。当Switch或Checkbox被点击时，会触发它们的onChanged回调，我们可以在此回调中处理选中状态改变逻辑。
![](../../static/docs/Pasted%20image%2020240130112928.jpeg)
```dart
class SwitchAndCheckBoxTestRoute extends StatefulWidget {
  @override
  _SwitchAndCheckBoxTestRouteState createState() => _SwitchAndCheckBoxTestRouteState();
}

class _SwitchAndCheckBoxTestRouteState extends State<SwitchAndCheckBoxTestRoute> {
  bool _switchSelected=true; //维护单选开关状态
  bool _checkboxSelected=true;//维护复选框状态
  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        Switch(
          value: _switchSelected,//当前状态
          onChanged:(value){
            //重新构建页面  
            setState(() {
              _switchSelected=value;
            });
          },
        ),
        Checkbox(
          value: _checkboxSelected,
          activeColor: Colors.red, //选中时的颜色
          onChanged:(value){
            setState(() {
              _checkboxSelected=value!;
            });
          } ,
        )
      ],
    );
  }
}
```

`Checkbox`的大小是固定的，**无法自定义**，而`Switch`只能定义宽度，**高度也是固定**的。值得一提的是`Checkbox`有一个属性`tristate` ，表示是否为三态，其默认值为`false` ，这时 Checkbox 有两种状态即“选中”和“不选中”，对应的 value 值为`true`和`false` ；如果`tristate`值为`true`时，value 的值会增加一个状态`null`

## 输入框及表单
### TextField
基础的表单界面：
![](../../static/docs/Pasted%20image%2020240130155245.jpeg)
```dart
TextField(
  autofocus: true,
  onChanged: (v) {
    print('onChange: $v');
  },
  decoration: const InputDecoration(
    labelText: "用户名",
    hintText: "用户名或邮箱",
    prefixIcon: Icon(Icons.person)
  ),
),
const TextField(
  decoration: InputDecoration(
    labelText: "密码",
    hintText: "您的登录密码",
    prefixIcon: Icon(Icons.lock)
  ),
  obscureText: true, // 是否隐藏输入内容
),
```

#### 获取输入的内容
1. 可以通过`onChanged`回调来获取
2. 通过`controller`直接获取：
```dart
//定义一个controller
TextEditingController _unameController = TextEditingController();

TextField(
    autofocus: true,
    controller: _unameController, //设置controller
    ...
)

print(_unameController.text)
```
#### 监听输入变化
1. 同样可以通过`onChanged`获取
2. 通过`controller`监听：
```dart
@override
void initState() {
  //监听输入改变  
  _unameController.addListener((){
    print(_unameController.text);
  });
}
```
`onChanged`是专门用于监听文本变化，而`controller`的功能却多一些，除了能监听文本变化外，它还可以设置默认值、选择文本:
```dart
final TextEditingController foo = TextEditingController(text: '张三');

void initState() {
	super.initState();
	// 定时器3秒后
	Future.delayed(const Duration(seconds: 3), () {
	  foo.text = 'San Zhang';
	});
}

TextField(
  controller: foo,
)
```
#### 控制焦点
1. `autofocus`属性可以控制自动聚焦
2. 也可以通过`FocusNode`和`FocusScopeNode`来控制，我们可以通过`FocusScope.of(context)` 来获取Widget树中默认的`FocusScopeNode`:
```dart
final FocusNode focusNodeFoo = FocusNode(); // 焦点
final FocusNode focusNodeBar = FocusNode();

TextField(
	controller: foo,
	focusNode: focusNodeFoo, // 焦点
), // 输入框组件
TextField(
	controller: bar,
	focusNode: focusNodeBar, // 焦点
), // 输入框组件
ElevatedButton(
	onPressed: () {
	  print('表单内容为${foo.text}');  // 笔记：如果为简单数据可以直接 $foo
	  print('表单内容为${bar.text}');
	  
	  FocusScope.of(context).unfocus(); // 如果是通过聚焦密码框聚焦的，那么提交后需要取消聚焦
	}, child: Text('提交'))
,
ElevatedButton(
	onPressed: () {
	  FocusScope.of(context).requestFocus(focusNodeBar); // 焦点聚焦
	}, child: Text('聚焦密码框'))
,
```
#### 自定义样式
通过`decoration`属性来定义输入框样式：
```dart
decoration: const InputDecoration( // 笔记：InputDecoration 为输入框的装饰器
  // 未获得焦点，去掉下划线
  enabledBorder: InputBorder.none,
  //获得焦点下划线设为蓝色
  focusedBorder: UnderlineInputBorder(
    borderSide: BorderSide(color: Colors.blue),
  ),
  labelText: '密码',
  hintText: '请输入密码',
  prefixIcon: Icon(Icons.password),
  border: OutlineInputBorder(),
),
```
直接通过InputDecoration的enabledBorder和focusedBorder来分别设置了输入框在未获取焦点和获得焦点后的下划线颜色，还有一种通过`Theme` Widget定义的方式：
```dart
Theme(
  data: Theme.of(context).copyWith(
      hintColor: Colors.grey[200], //定义下划线颜色
      inputDecorationTheme: InputDecorationTheme(
          labelStyle: TextStyle(color: Colors.red),//定义label字体样式
          hintStyle: TextStyle(color: Colors.yellow, fontSize: 14.0)//定义提示文本样式
      )
  ),
  child: Column(
    children: <Widget>[
      TextField(
        decoration: InputDecoration(
            labelText: "用户名",
            hintText: "用户名或邮箱",
            prefixIcon: Icon(Icons.person)
        ),
      ),
      TextField(
        decoration: InputDecoration(
            prefixIcon: Icon(Icons.lock),
            labelText: "密码",
            hintText: "您的登录密码",
            hintStyle: TextStyle(color: Colors.grey, fontSize: 13.0)
        ),
        obscureText: true,
      )
    ],
  )
),
```
组件中decoration优先级高于Theme
> 通过这种组件组合的方式，也可以定义背景圆角等。一般来说，优先通过`decoration`来自定义样式，如果`decoration`实现不了，再用widget组合的方式。

#### 完整示例
```dart
class Home extends StatefulWidget {
  const Home({super.key});

  @override
  State<Home> createState() => _HomeState();
}

class _HomeState extends State<Home> {
  final TextEditingController foo = TextEditingController(text: '张三'); // 控制器
  final TextEditingController bar = TextEditingController();

  final FocusNode focusNodeFoo = FocusNode(); // 焦点
  final FocusNode focusNodeBar = FocusNode();

  @override
  void initState() {
    super.initState();
    foo.addListener(() { // 监听输入
      print('controller监听: ${foo.text}');
    });
    focusNodeBar.addListener((){ // 监听焦点变化
      print('focusNodeBar: ${focusNodeBar.hasFocus}');
    });
    // 定时器3秒后
    Future.delayed(const Duration(seconds: 3), () {
      foo.text = 'San Zhang';
    });
  }

  @override
  void dispose() {
    foo.dispose(); // 释放控制器资源
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text(
          '表单',
          style: TextStyle(
            fontSize: 20.0,
            color: Colors.white,
          ),
        ),
        backgroundColor: const Color(0xFFFF0000), // ARGB(FF, FF, 0, 0)
      ),
      body: Column(
        children: [
          TextField(
            controller: foo,
            focusNode: focusNodeFoo, // 焦点
            decoration: const InputDecoration(
              labelText: '用户名',
              hintText: '请输入用户名',
              prefixIcon: Icon(Icons.person),
            ),
          ), // 输入框组件
          TextField(
            controller: bar,
            focusNode: focusNodeBar, // 焦点
            decoration: const InputDecoration( // 笔记：InputDecoration 为输入框的装饰器
              // 未获得焦点，去掉下划线
              enabledBorder: InputBorder.none,
              //获得焦点下划线设为蓝色
              focusedBorder: UnderlineInputBorder(
                borderSide: BorderSide(color: Colors.blue),
              ),
              labelText: '密码',
              hintText: '请输入密码',
              prefixIcon: Icon(Icons.password),
              border: OutlineInputBorder(),
            ),
            obscureText: true, // 隐藏文本
            keyboardType: TextInputType.number, // 唤起的键盘类型，并非限制输入类型
            maxLength: 10,
            onChanged: (val) {
              print('onChanged: $val');
            },
            // 限制输入数字类型
            inputFormatters: [
              FilteringTextInputFormatter.digitsOnly, // 只允许输入数字
              LengthLimitingTextInputFormatter(6), // 限制长度
            ],
          ), // 输入框组件
          ElevatedButton(
            onPressed: () {
              print('表单内容为${foo.text}');  // 笔记：如果为简单数据可以直接 $foo
              print('表单内容为${bar.text}');
              
              FocusScope.of(context).unfocus(); // 如果是通过聚焦密码框聚焦的，那么提交后需要取消聚焦
            }, child: Text('提交'))
          ,
          ElevatedButton(
            onPressed: () {
              FocusScope.of(context).requestFocus(focusNodeBar); // 焦点聚焦
            }, child: Text('聚焦密码框'))
          ,
        ],
      ),
    );
  }
}

```

### 表单Form
#### Form
`Form`继承自`StatefulWidget`对象，它对应的状态类为`FormState`:
```dart
Form({
  required Widget child,
  bool autovalidate = false,
  WillPopCallback onWillPop,
  VoidCallback onChanged,
})
```
#### FormField
`Form`的子孙元素必须是`FormField`类型，`FormField`是一个抽象类，定义几个属性，`FormState`内部通过它们来完成操作。
为了方便使用，Flutter 还提供了一个`TextFormField`组件，它继承自`FormField`类，也是`TextField`的一个包装类，所以除了`FormField`定义的属性之外，它还包括`TextField`的属性。
`FormField`部分定义如下：
```dart
const FormField({
  ...
  FormFieldSetter<T> onSaved, //保存回调
  FormFieldValidator<T>  validator, //验证回调
  T initialValue, //初始值
  bool autovalidate = false, //是否自动校验。
})
```
#### FormState
`FormState`为`Form`的`State`类，可以通过`Form.of()`或`GlobalKey`获得。我们可以通过它来对`Form`的子孙`FormField`进行统一操作。我们看看其常用的三个方法：
- `FormState.validate()`：调用此方法后，会调用`Form`子孙`FormField的validate`回调，如果有一个校验失败，则返回false，所有校验失败项都会返回用户返回的错误提示。
- `FormState.save()`：调用此方法后，会调用`Form`子孙`FormField`的`save`回调，用于保存表单内容
- `FormState.reset()`：调用此方法后，会将子孙`FormField`的内容清空。
#### 示例
1. 用户名不能为空，如果为空则提示“用户名不能为空”。
2. 密码不能少于 6 位，如果小于 6 为则提示“密码不能少于 6 位”。
```dart
import 'package:flutter/material.dart';

// 定义FormTestRoute类，它是一个有状态的widget，用于展示表单
class FormTestRoute extends StatefulWidget {
  const FormTestRoute({super.key});

  @override
  _FormTestRouteState createState() => _FormTestRouteState();
}

// 定义_FormTestRouteState类，它是FormTestRoute的状态类
class _FormTestRouteState extends State<FormTestRoute> {
  // 定义两个TextEditingController，分别用于控制用户名和密码输入框
  final TextEditingController _unameController = TextEditingController();
  final TextEditingController _pwdController = TextEditingController();

  // 定义一个global key，用于获取FormState
  final GlobalKey _formKey = GlobalKey<FormState>();

  @override
  Widget build(BuildContext context) {
    // 使用Form widget来收集和校验输入内容
    return Form(
      key: _formKey, // 设置globalKey，用于后面获取FormState
      autovalidateMode: AutovalidateMode.onUserInteraction, // 设置表单自动校验模式
      child: Column(
        children: <Widget>[
          // 用户名输入框
          TextFormField(
            autofocus: true, // 自动获取焦点
            controller: _unameController, // 设置控制器
            decoration: const InputDecoration( // 设置装饰器
              labelText: "用户名", // 标签文本
              hintText: "用户名或邮箱", // 占位文本
              icon: Icon(Icons.person), // 左侧图标
            ),
            // 校验用户名函数
            validator: (v) {
              return v!.trim().isNotEmpty ? null : "用户名不能为空"; // 判断用户名是否为空
            },
          ),
          // 密码输入框
          TextFormField(
            controller: _pwdController, // 设置控制器
            decoration: const InputDecoration( // 设置装饰器
              labelText: "密码", // 标签文本
              hintText: "您的登录密码", // 占位文本
              icon: Icon(Icons.lock), // 左侧图标
            ),
            obscureText: true, // 密码隐藏
            // 校验密码函数
            validator: (v) {
              return v!.trim().length > 5 ? null : "密码不能少于6位"; // 判断密码长度是否大于5
            },
          ),
          // 登录按钮
          Padding(
            padding: const EdgeInsets.only(top: 28.0), // 上边距
            child: Row(
              children: <Widget>[
                Expanded(
                  child: ElevatedButton(
                    child: const Padding(
                      padding: EdgeInsets.all(16.0), // 内边距
                      child: Text("登录"), // 按钮文本
                    ),
                    onPressed: () {
                      // 当按钮按下时的处理函数
                      // 通过_formKey.currentState 获取FormState后，
                      // 调用validate()方法校验用户名密码是否合法，校验
                      // 通过后再提交数据。
                      if ((_formKey.currentState as FormState).validate()) {
                        // 验证通过后的操作
                        // 获取表单数据
                        print('用户名：${_unameController.text}'); // 打印用户名
                        print('密码：${_pwdController.text}'); // 打印密码
                      }
                    },
                  ),
                ),
              ],
            ),
          )
        ],
      ),
    );
  }
}

```

> `validator` 函数必须是一个同步函数，它不能是异步的。这是因为`validator`需要立即返回一个字符串作为错误信息，或者返回`null`表示输入是有效的。

#### 实现一个异步校验
```dart
class _FormTestRouteState extends State<FormTestRoute> {
  // ... 其他代码

  String? _usernameError;

  // 用户名异步校验函数
  void _validateUsername(String value) async {
    // 模拟网络请求检查用户名
    final bool usernameExists = await checkUsernameExist(value);
    setState(() {
      // 根据异步结果设置错误信息
      _usernameError = usernameExists ? '用户名已存在' : null;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Form(
      // ... 其他代码
      child: Column(
        children: <Widget>[
          TextFormField(
            // ... 其他装饰器代码
            onChanged: (value) {
              // 当用户停止输入一段时间后进行异步校验
              debounce(_validateUsername(value));
            },
            // 校验用户名（同步）
            validator: (value) {
              // 直接返回异步校验后设置的错误信息
              return _usernameError;
            },
          ),
          // ... 其他 TextFormField 和按钮代码
        ],
      ),
    );
  }
  
  // 防抖函数，用于延迟执行校验
  void debounce(VoidCallback callback, {Duration duration = const Duration(milliseconds: 500)}) {
    // ... 防抖实现代码
  }
  
  Future<bool> checkUsernameExist(String username) async {
    // ... 异步请求服务器检查用户名
  }
}
```