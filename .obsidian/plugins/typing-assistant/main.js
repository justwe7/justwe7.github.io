/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TypingAsstPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/components/command-menu.ts
var import_obsidian = require("obsidian");

// src/constants.ts
var ICON_MAP = {
  ["text"]: '<svg preserveAspectRatio="meet" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"  ><path d="M484.053333 789.333333l-55.018666-159.573333H199.893333L144.448 789.333333H48.64L265.706667 188.074667h100.416L583.210667 789.333333h-99.178667z m-172.928-492.074666l-87.509333 254.165333h181.674667l-87.082667-254.165333h-7.082667z m466.922667 424.149333c67.498667 0 117.504-42.901333 117.504-99.157333v-37.909334l-110.848 7.082667c-62.506667 4.16-90.837333 25.408-90.837333 65.408 0 40.832 35.413333 64.576 84.181333 64.576z m-22.933333 75.434667c-87.488 0-151.253333-52.906667-151.253334-135.850667 0-81.664 60.842667-128.746667 168.746667-135.402667l122.944-7.082666v-39.168c0-47.914667-31.68-75.008-92.928-75.008-50.005333 0-84.586667 18.346667-94.592 50.410666h-86.656c9.173333-77.909333 82.496-127.914667 185.408-127.914666 113.749333 0 177.92 56.682667 177.92 152.512V789.333333h-86.250667v-63.744h-7.082666c-27.093333 45.418667-76.672 71.253333-136.256 71.253334z" fill="#14181F" ></path></svg>',
  ["heading1"]: '<svg preserveAspectRatio="meet" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" ><path d="M835.626667 349.397333A42.666667 42.666667 0 0 1 853.333333 384v426.666667a42.666667 42.666667 0 0 1-85.333333 0v-367.488l-71.850667 23.978666a42.666667 42.666667 0 0 1-26.965333-80.981333l128-42.666667a42.666667 42.666667 0 0 1 38.4 5.888zM128 170.666667a42.666667 42.666667 0 0 1 42.666667 42.666666v256h256V213.333333a42.666667 42.666667 0 1 1 85.333333 0v597.333334a42.666667 42.666667 0 1 1-85.333333 0v-256H170.666667v256a42.666667 42.666667 0 1 1-85.333334 0V213.333333a42.666667 42.666667 0 0 1 42.666667-42.666666z" fill="#14181F" ></path></svg>',
  ["heading2"]: '<svg preserveAspectRatio="meet" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" ><path d="M768 426.666667a85.333333 85.333333 0 0 0-85.333333 85.333333v21.333333a42.666667 42.666667 0 1 1-85.333334 0V512a170.666667 170.666667 0 0 1 170.666667-170.666667h7.338667a163.328 163.328 0 0 1 115.498666 278.869334L742.997333 768H896a42.666667 42.666667 0 1 1 0 85.333333h-256a42.666667 42.666667 0 0 1-30.165333-72.832l220.672-220.672A77.994667 77.994667 0 0 0 775.338667 426.666667H768zM128 170.666667a42.666667 42.666667 0 0 1 42.666667 42.666666v256h256V213.333333a42.666667 42.666667 0 1 1 85.333333 0v597.333334a42.666667 42.666667 0 1 1-85.333333 0v-256H170.666667v256a42.666667 42.666667 0 1 1-85.333334 0V213.333333a42.666667 42.666667 0 0 1 42.666667-42.666666z" fill="#14181F"></path></svg>',
  ["heading3"]: '<svg preserveAspectRatio="meet" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" ><path d="M597.333333 384a42.666667 42.666667 0 0 1 42.666667-42.666667h256a42.666667 42.666667 0 0 1 30.165333 72.832l-105.941333 105.984A170.752 170.752 0 0 1 768 853.333333a170.666667 170.666667 0 0 1-160.938667-113.877333 42.666667 42.666667 0 0 1 80.469334-28.373333A85.333333 85.333333 0 1 0 768 597.333333h-42.666667a42.666667 42.666667 0 0 1-30.165333-72.832L793.002667 426.666667H640a42.666667 42.666667 0 0 1-42.666667-42.666667zM128 170.666667a42.666667 42.666667 0 0 1 42.666667 42.666666v256h256V213.333333a42.666667 42.666667 0 1 1 85.333333 0v597.333334a42.666667 42.666667 0 1 1-85.333333 0v-256H170.666667v256a42.666667 42.666667 0 1 1-85.333334 0V213.333333a42.666667 42.666667 0 0 1 42.666667-42.666666z" fill="#14181F" ></path></svg>',
  ["heading4"]: '<svg preserveAspectRatio="meet" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" ><path d="M780.714667 343.296a42.666667 42.666667 0 0 1 28.032 53.418667L719.36 682.666667H896a42.666667 42.666667 0 1 1 0 85.333333h-234.666667a42.666667 42.666667 0 0 1-40.704-55.381333l106.666667-341.333334a42.666667 42.666667 0 0 1 53.418667-27.989333z" fill="#14181F" ></path><path d="M853.333333 554.666667a42.666667 42.666667 0 0 1 42.666667 42.666666v213.333334a42.666667 42.666667 0 1 1-85.333333 0v-213.333334a42.666667 42.666667 0 0 1 42.666666-42.666666zM128 170.666667a42.666667 42.666667 0 0 1 42.666667 42.666666v256h256V213.333333a42.666667 42.666667 0 1 1 85.333333 0v597.333334a42.666667 42.666667 0 1 1-85.333333 0v-256H170.666667v256a42.666667 42.666667 0 1 1-85.333334 0V213.333333a42.666667 42.666667 0 0 1 42.666667-42.666666z" fill="#14181F"></path></svg>',
  ["heading5"]: '<svg preserveAspectRatio="meet" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" ><path d="M683.946667 373.674667A42.666667 42.666667 0 0 1 725.333333 341.333333h170.666667a42.666667 42.666667 0 1 1 0 85.333334h-137.301333l-22.016 88.234666A170.666667 170.666667 0 1 1 640 795.562667a42.666667 42.666667 0 1 1 64-56.448 85.333333 85.333333 0 1 0 0-112.896 42.666667 42.666667 0 0 1-73.386667-38.528l53.333334-214.016zM128 170.666667a42.666667 42.666667 0 0 1 42.666667 42.666666v256h256V213.333333a42.666667 42.666667 0 1 1 85.333333 0v597.333334a42.666667 42.666667 0 1 1-85.333333 0v-256H170.666667v256a42.666667 42.666667 0 1 1-85.333334 0V213.333333a42.666667 42.666667 0 0 1 42.666667-42.666666z" fill="#14181F" ></path></svg>',
  ["heading6"]: '<svg preserveAspectRatio="meet" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" ><path d="M831.274667 303.957333a42.666667 42.666667 0 0 1 16.725333 57.984l-83.498667 151.466667a170.453333 170.453333 0 0 1 88.746667 22.741333 169.557333 169.557333 0 0 1 62.506667 232.277334 171.093333 171.093333 0 0 1-232.96 62.165333 169.557333 169.557333 0 0 1-62.805334-231.850667l153.301334-278.016a42.666667 42.666667 0 0 1 57.984-16.768z m-20.48 306.176a85.76 85.76 0 0 0-116.736 31.018667 84.224 84.224 0 0 0 31.189333 115.456 85.76 85.76 0 0 0 116.736-31.018667 84.224 84.224 0 0 0-31.232-115.456zM128 170.666667a42.666667 42.666667 0 0 1 42.666667 42.666666v256h256V213.333333a42.666667 42.666667 0 1 1 85.333333 0v597.333334a42.666667 42.666667 0 1 1-85.333333 0v-256H170.666667v256a42.666667 42.666667 0 1 1-85.333334 0V213.333333a42.666667 42.666667 0 0 1 42.666667-42.666666z" fill="#14181F" ></path></svg>',
  ["todoList"]: '<svg  viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M977.2 782.8v-736H46.8v930.4h889.1v-76H122.8V122.8h778.4v660z" fill="#454545" p-id="1500"></path><path d="M274.8 459.8L227.2 519l244.2 196 385.1-373.3-52.9-54.6-336.9 326.7z" fill="#454545" p-id="1501"></path></svg>',
  ["linkBookMark"]: '<svg  viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="meet"><path d="M26.2401 16.373L17.1001 7.23303C14.4388 4.57168 10.0653 4.6303 7.33158 7.36397C4.59791 10.0976 4.53929 14.4712 7.20064 17.1325L15.1359 25.0678" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M32.9027 23.0031L40.838 30.9384C43.4994 33.5998 43.4407 37.9733 40.7071 40.707C37.9734 43.4407 33.5999 43.4993 30.9385 40.8379L21.7985 31.6979" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M26.1093 26.1416C28.843 23.4079 28.9016 19.0344 26.2403 16.373" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M21.7989 21.7984C19.0652 24.5321 19.0066 28.9056 21.6679 31.5669" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/></svg>',
  ["bulletList"]: '<svg  viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="meet"><path d="M9 42C11.2091 42 13 40.2091 13 38C13 35.7909 11.2091 34 9 34C6.79086 34 5 35.7909 5 38C5 40.2091 6.79086 42 9 42Z" stroke="#333" stroke-width="4" stroke-linejoin="round"/><path d="M9 14C11.2091 14 13 12.2092 13 10C13 7.79086 11.2091 6 9 6C6.79086 6 5 7.79086 5 10C5 12.2092 6.79086 14 9 14Z" stroke="#333" stroke-width="4" stroke-linejoin="round"/><path d="M9 28C11.2091 28 13 26.2092 13 24C13 21.7908 11.2091 20 9 20C6.79086 20 5 21.7908 5 24C5 26.2092 6.79086 28 9 28Z" stroke="#333" stroke-width="4" stroke-linejoin="round"/><path d="M21 24H43" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M21 38H43" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M21 10H43" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/></svg>',
  ["numberList"]: '<svg  viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="meet" ><path d="M9 4V13" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M12 13H6" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M12 27H6" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M6 19.9998C6 19.9998 9 16.9998 11 19.9998C13 22.9999 6 26.9998 6 26.9998" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M6.00016 34.5001C6.00016 34.5001 8.00016 31.5 11.0002 33.5C14.0002 35.5 11.0002 38 11.0002 38C11.0002 38 14.0002 40.5 11.0002 42.5C8.00015 44.5 6.00015 41.5 6.00015 41.5" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M11 38H9" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M9 4L6 6" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M21 24H43" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M21 38H43" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M21 10H43" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/></svg>',
  ["bold"]: '<svg t="1697275107362" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" ><path d="M128 128c0-35.4 28.6-64 64-64h384c141.4 0 256 114.6 256 256 0 62.6-22.6 120.2-60 164.6 74.2 44.8 124 126.2 124 219.4 0 141.4-114.6 256-256 256H192c-35.4 0-64-28.6-64-64s28.6-64 64-64h32V192H192C156.6 192 128 163.4 128 128z m448 320c70.6 0 128-57.4 128-128s-57.4-128-128-128H352v256h224z m-224 128v256h288c70.6 0 128-57.4 128-128s-57.4-128-128-128H352z" ></path></svg>',
  ["strikethrough"]: '<svg  viewBox="0 0 1024 1024"  xmlns="http://www.w3.org/2000/svg" ><path d="M1005.714286 512q8 0 13.142857 5.142857t5.142857 13.142857v36.571429q0 8-5.142857 13.142857t-13.142857 5.142857H18.285714q-8 0-13.142857-5.142857t-5.142857-13.142857v-36.571429q0-8 5.142857-13.142857t13.142857-5.142857h987.428572zM276 475.428571q-16-20-29.142857-45.714285-27.428571-55.428571-27.428572-107.428572 0-103.428571 76.571429-176.571428 76-72.571429 224.571429-72.571429 28.571429 0 95.428571 10.857143 37.714286 6.857143 101.142857 27.428571 5.714286 21.714286 12 67.428572 8 70.285714 8 104.571428 0 10.285714-2.857143 25.714286l-6.857143 1.714286-48-3.428572-8-1.142857q-28.571429-85.142857-58.857142-117.142857-50.285714-52-120-52-65.142857 0-104 33.714286-38.285714 33.142857-38.285715 83.428571 0 41.714286 37.714286 80t159.428571 73.714286q39.428571 11.428571 98.857143 37.714286 33.142857 16 54.285715 29.714285H276z m289.714286 146.285715h234.857143q4 22.285714 4 52.571428 0 63.428571-23.428572 121.142857-13.142857 31.428571-40.571428 59.428572-21.142857 20-62.285715 46.285714-45.714286 27.428571-87.428571 37.714286-45.714286 12-116 12-65.142857 0-111.428572-13.142857l-80-22.857143q-32.571429-9.142857-41.142857-16-4.571429-4.571429-4.571428-12.571429v-7.428571q0-61.714286-1.142857-89.142857-0.571429-17.142857 0-38.857143l1.142857-21.142857v-25.142857l58.285714-1.142858q8.571429 19.428571 17.142857 40.571429t12.857143 32 7.142857 15.428571q20 32.571429 45.714286 53.714286 24.571429 20.571429 60 32.571429 33.714286 12.571429 75.428571 12.571428 36.571429 0 79.428572-15.428571 44-14.857143 69.714285-49.142857 26.857143-34.857143 26.857143-73.714286 0-48-46.285714-89.714286-19.428571-16.571429-78.285714-40.571428z" ></path></svg>',
  ["italics"]: '<svg preserveAspectRatio="meet"  viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill="#14181F" d="M20 6H36" stroke="#14181F" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/><path d="M12 42H28" stroke="#333" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/><path d="M29 5.95215L19 41.9998" stroke="#333" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  ["underline"]: '<svg preserveAspectRatio="meet" viewBox="0 0 1024 1024"  xmlns="http://www.w3.org/2000/svg" ><path d="M934.4 978.432H89.6a46.08 46.08 0 0 1-46.912-46.976 46.08 46.08 0 0 1 46.912-46.912h844.8a46.08 46.08 0 0 1 46.912 46.912 46.08 46.08 0 0 1-46.912 46.976zM512 828.224a332.48 332.48 0 0 1-333.248-333.248V88.32a46.08 46.08 0 0 1 46.976-46.912 46.08 46.08 0 0 1 46.912 46.912v406.72A240.384 240.384 0 0 0 512 734.336a239.36 239.36 0 0 0 239.36-239.36V88.32a46.08 46.08 0 0 1 46.912-46.912 46.08 46.08 0 0 1 46.976 46.912v406.72A333.504 333.504 0 0 1 512 828.224z" fill="#14181F" ></path></svg>',
  ["code"]: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" ><path d="M240.496 272c-13.504 0-25.664 5.632-34.384 14.608l-0.048-0.048L16.848 475.76A47.664 47.664 0 0 0 0 512c0 13.504 5.616 25.664 14.592 34.368l-0.032 0.064 192 192 0.048-0.064A47.68 47.68 0 0 0 240 752a48 48 0 0 0 48-48c0-12.992-5.216-24.752-13.616-33.392l0.048-0.048-158.304-158.32 157.808-157.808-0.048-0.048A47.808 47.808 0 0 0 288.496 320a48 48 0 0 0-48-48z m784 240c0-14.56-6.608-27.44-16.848-36.24L818.432 286.56l-0.032 0.048A47.872 47.872 0 0 0 784 272a48 48 0 0 0-48 48c0 13.504 5.632 25.664 14.608 34.384l-0.048 0.048 157.808 157.808-158.32 158.32 0.048 0.048A47.808 47.808 0 0 0 736.48 704a48 48 0 0 0 48 48c12.992 0 24.752-5.216 33.408-13.632l0.048 0.064 192-192-0.048-0.064A47.68 47.68 0 0 0 1024.496 512zM640 128c-20.8 0-38.496 13.232-45.168 31.712L339.2 830.784a48 48 0 0 0 89.968 33.504L684.8 193.216A48 48 0 0 0 640 128z" fill="#14181F" p-id="15138"></path></svg>',
  ["divide"]: '<svg  viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="meet"><path d="M5 24H43" stroke="#14181F" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M21 38H27" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M37 38H43" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M21 10H27" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M5 38H11" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M5 10H11" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/><path d="M37 10H43" stroke="#333" stroke-width="4" stroke-linecap="square" stroke-linejoin="round"/></svg>',
  ["quote"]: '<svg  viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="meet"><path fill-rule="evenodd" clip-rule="evenodd" d="M18.8533 9.11587C11.3227 13.9521 7.13913 19.5811 6.30256 26.0028C5.00021 35.9999 13.9404 40.8932 18.4703 36.4966C23.0002 32.1 20.2848 26.5195 17.0047 24.9941C13.7246 23.4686 11.7187 23.9999 12.0686 21.9614C12.4185 19.923 17.0851 14.2712 21.1849 11.6391C21.4569 11.4078 21.5604 10.959 21.2985 10.6185C21.1262 10.3946 20.7883 9.95545 20.2848 9.30102C19.8445 8.72875 19.4227 8.75017 18.8533 9.11587Z" fill="#14181F"/><path fill-rule="evenodd" clip-rule="evenodd" d="M38.6789 9.11587C31.1484 13.9521 26.9648 19.5811 26.1282 26.0028C24.8259 35.9999 33.7661 40.8932 38.296 36.4966C42.8259 32.1 40.1105 26.5195 36.8304 24.9941C33.5503 23.4686 31.5443 23.9999 31.8943 21.9614C32.2442 19.923 36.9108 14.2712 41.0106 11.6391C41.2826 11.4078 41.3861 10.959 41.1241 10.6185C40.9519 10.3946 40.614 9.95545 40.1105 9.30102C39.6702 8.72875 39.2484 8.75017 38.6789 9.11587Z" fill="#14181F"/></svg>',
  ["link"]: '<svg  viewBox="0 0 1024 1024"  xmlns="http://www.w3.org/2000/svg"><path d="M725.333333 42.666667q50.346667 0 97.152 18.986667t83.84 55.978667 56.021333 83.84 18.986667 97.152q0 50.005333-19.157333 97.152t-55.850667 83.84l-128 128q-3.669333 3.669333-11.008 10.325333-35.669333 31.658667-79.658667 48.170667t-90.325333 16.512q-58.325333 0-110.336-25.002667-38.997333-18.346667-70.656-50.005333t-50.005333-70.656q25.002667-25.002667 60.330667-25.002667 12.330667 0 25.002667 3.669333 21.674667 34.986667 56.661333 56.661333 41.002667 25.002667 89.002667 25.002667 33.322667 0 64.682667-12.672t56.021333-37.333333l128-128q24.661333-24.661333 37.333333-56.021333t12.672-64.682667-12.672-64.682667-37.333333-56.021333-56.021333-37.333333-64.682667-12.672-64.682667 12.672-56.021333 37.333333l-89.685333 89.685333q-42.666667-11.648-88.32-11.648-7.338667 0-20.650667 0.682667 6.656-7.338667 10.325333-11.008l128-128q36.650667-36.650667 83.84-55.850667t97.152-19.157333zM426.666667 341.333333q58.325333 0 110.336 25.002667 38.997333 18.346667 70.656 50.005333t50.005333 70.656q-25.002667 25.002667-60.330667 25.002667-12.330667 0-25.002667-3.669333-21.674667-34.986667-56.661333-56.661333-41.002667-25.002667-89.002667-25.002667-33.322667 0-64.682667 12.672t-56.021333 37.333333l-128 128q-24.661333 24.661333-37.333333 56.021333t-12.672 64.682667 12.672 64.682667 37.333333 56.021333 56.021333 37.333333 64.682667 12.672 64.682667-12.672 56.021333-37.333333l89.685333-89.685333q42.666667 11.648 88.32 11.648 7.338667 0 20.650667-0.682667-6.656 7.338667-10.325333 11.008l-128 128q-36.992 36.992-83.84 56.021333t-97.152 18.986667q-50.005333 0-97.152-19.157333t-83.84-55.850667q-36.992-36.992-56.021333-83.84t-18.986667-97.152 18.986667-97.152 56.021333-83.84l128-128q3.669333-3.669333 11.008-10.325333 35.669333-31.658667 79.658667-48.170667t90.325333-16.512z"  fill="#14181F"></path></svg>',
  ["math"]: '<svg viewBox="0 0 1024 1024"  xmlns="http://www.w3.org/2000/svg"><path d="M358.4 298.666667a85.333333 85.333333 0 0 1 85.333333-85.333334h85.333334a42.666667 42.666667 0 0 0 42.666666-42.666666 42.666667 42.666667 0 0 0-42.666666-42.666667h-85.333334a170.666667 170.666667 0 0 0-170.666666 170.666667v597.333333a42.666667 42.666667 0 0 0 42.666666 42.666667 42.666667 42.666667 0 0 0 42.666667-42.666667z" fill="#14181F" p-id="13347"></path><path d="M145.066667 426.666667m42.666666 0l298.666667 0q42.666667 0 42.666667 42.666666l0 0q0 42.666667-42.666667 42.666667l-298.666667 0q-42.666667 0-42.666666-42.666667l0 0q0-42.666667 42.666666-42.666666Z" fill="#666666" p-id="13348"></path><path d="M865.706667 426.666667a42.666667 42.666667 0 0 0-37.12 21.333333l-85.333334 149.333333-85.333333-149.333333a42.666667 42.666667 0 0 0-37.12-21.333333 42.666667 42.666667 0 0 0-36.693333 64l110.933333 192-110.933333 192a42.666667 42.666667 0 0 0 36.693333 64 42.666667 42.666667 0 0 0 37.12-21.333334l85.333333-149.333333 85.333334 149.333333a42.666667 42.666667 0 0 0 37.12 21.333334 42.666667 42.666667 0 0 0 36.693333-64l-110.933333-192 110.933333-192a42.666667 42.666667 0 0 0-36.693333-64z" fill="#666666" p-id="13349"></path></svg>',
  ["highlight"]: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" ><path d="M576 182.656l-128 32V341.333333h128V182.656zM661.333333 341.333333V155.306667a64 64 0 0 0-79.530666-62.08l-170.666667 42.666666A64 64 0 0 0 362.666667 197.973333V341.333333h-42.666667a64 64 0 0 0-64 64v128h-42.666667a64 64 0 0 0-64 64v320h85.333334V618.666667h106.666666v-192h341.333334v192h106.666666v298.666666h85.333334V597.333333a64 64 0 0 0-64-64h-42.666667v-128a64 64 0 0 0-64-64h-42.666667z" fill="#14181F" p-id="8832"></path></svg>',
  ["note-call-out"]: '<svg xmlns="http://www.w3.org/2000/svg" width="108" height="108" viewBox="0 0 24 24" fill="none" stroke="#000000""><path d="M4.333 16.048L16.57 3.81a2.56 2.56 0 0 1 3.62 3.619L7.951 19.667a2 2 0 0 1-1.022.547L3 21l.786-3.93a2 2 0 0 1 .547-1.022z"/><path d="M14.5 6.5l3 3"/></svg>',
  ["abstract-call-out"]: '<svg xmlns="http://www.w3.org/2000/svg" width="108" height="108" viewBox="0 0 24 24" fill="none" stroke="#000000"><path d="M4 4v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8.342a2 2 0 0 0-.602-1.43l-4.44-4.342A2 2 0 0 0 13.56 2H6a2 2 0 0 0-2 2z"/><path d="M9 13h6"/><path d="M9 17h3"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/></svg>',
  ["info-call-out"]: '<svg xmlns="http://www.w3.org/2000/svg" width="108" height="108" viewBox="0 0 24 24" fill="none" stroke="#000000"><circle cx="12" cy="12" r="10"/><path d="M12 7h.01"/><path d="M10 11h2v5"/><path d="M10 16h4"/></svg>',
  ["todo-call-out"]: '<svg xmlns="http://www.w3.org/2000/svg" width="108" height="108" viewBox="0 0 24 24" fill="none" stroke="#000000"><path d="M8 12.5l3 3 5-6"/><circle cx="12" cy="12" r="10"/></svg>',
  ["tip-call-out"]: '<svg xmlns="http://www.w3.org/2000/svg" width="108" height="108" viewBox="0 0 24 24" fill="none" stroke="#000000"><path d="M12 22c-4.97 0-9-2.582-9-7v-.088C3 12.794 4.338 11.1 6.375 10c1.949-1.052 3.101-2.99 2.813-5l-.563-3 2.086.795c3.757 1.43 6.886 3.912 8.914 7.066A8.495 8.495 0 0 1 21 14.464V15c0 1.562-.504 2.895-1.375 3.965"/><path d="M12 22c-1.657 0-3-1.433-3-3.2 0-1.4 1.016-2.521 1.91-3.548L12 14l1.09 1.252C13.984 16.28 15 17.4 15 18.8c0 1.767-1.343 3.2-3 3.2z"/></svg>',
  ["success-call-out"]: '<svg xmlns="http://www.w3.org/2000/svg" width="108" height="108" viewBox="0 0 24 24" fill="none" stroke="#000000"><path d="M4 12l6 6L20 6"/></svg>',
  ["question-call-out"]: '<svg xmlns="http://www.w3.org/2000/svg" width="108" height="108" viewBox="0 0 24 24" fill="none" stroke="#000000"><circle cx="12" cy="12" r="10"/><path d="M10 8.484C10.5 7.494 11 7 12 7c1.246 0 2 .989 2 1.978s-.5 1.483-2 2.473V13m0 3.5v.5"/></svg>',
  ["warning-call-out"]: '<svg xmlns="http://www.w3.org/2000/svg" width="108" height="108" viewBox="0 0 24 24" fill="none" stroke="#000000"><path d="M12 9v5"/><path d="M12 17.5v.5"/><path d="M2.232 19.016L10.35 3.052c.713-1.403 2.59-1.403 3.302 0l8.117 15.964C22.45 20.36 21.544 22 20.116 22H3.883c-1.427 0-2.334-1.64-1.65-2.984z"/></svg>',
  ["failure-call-out"]: '<svg xmlns="http://www.w3.org/2000/svg" width="108" height="108" viewBox="0 0 24 24" fill="none" stroke="#000000"><path d="M20 20L4 4m16 0L4 20"/></svg>',
  ["danger-call-out"]: '<svg xmlns="http://www.w3.org/2000/svg" width="108" height="108" viewBox="0 0 24 24" fill="none" stroke="#000000"><path d="M17.684 3.603c.521-.659.03-1.603-.836-1.603h-6.716c-.375 0-.722.192-.909.502l-5.082 8.456c-.401.666.103 1.497.908 1.497h3.429l-3.23 8.065c-.467 1.02.795 1.953 1.643 1.215L20 9.331h-6.849l4.533-5.728z"/></svg>',
  ["bug-call-out"]: '<svg xmlns="http://www.w3.org/2000/svg" width="108" height="108" viewBox="0 0 24 24" fill="none" stroke="#000000"><path d="M5 9a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v5a7 7 0 0 1-7 7v0a7 7 0 0 1-7-7V9z"/><path d="M8 6v-.425c0-.981.384-1.96 1.326-2.238 1.525-.45 3.823-.45 5.348 0C15.616 3.615 16 4.594 16 5.575V6"/><path d="M18.5 7.5L22 4"/><path d="M5.5 7.5L2 4"/><path d="M6 18l-4 3"/><path d="M5 12H1.5"/><path d="M22.5 12H19"/><path d="M18 18l4 3"/><path d="M12 13v8"/></svg>',
  ["example-call-out"]: '<svg xmlns="http://www.w3.org/2000/svg" width="108" height="108" viewBox="0 0 24 24" fill="none" stroke="#000000"><path d="M5 6h14M5 12h14M5 18h14"/></svg>',
  ["tag"]: '<svg  viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M525.249536 102.7072c9.216 0 18.0736 3.584 24.576 9.9328l461.568 450.4576c9.5744 11.264 13.9776 25.1904 12.288 39.68-1.3824 11.9808-6.3488 22.9888-16.4864 34.4576l-278.6304 268.0832a57.4976 57.4976 0 0 1-40.0384 16.2816c-14.1312 0-25.9584-5.0176-40.6528-16.2816l-8.704-6.912 48.1792-48.2304 227.1744-218.368c8.6016-9.9328 12.8512-21.8112 12.8512-35.6864a42.7008 42.7008 0 0 0-14.08-33.3824l-420.352-408.3712c-20.2752-18.944-41.216-32.3072-62.7712-40.0896-28.5184-10.24-51.5584-11.4176-43.4176-11.52h138.496zM349.070336 102.4c9.216 0 18.0736 3.584 24.576 9.9328l461.568 450.4576c9.5232 11.264 13.9776 25.1392 12.288 39.6288-1.3824 11.9808-6.3488 23.04-16.4864 34.4576l-278.6816 268.0832a57.4976 57.4976 0 0 1-40.0384 16.3328c-14.08 0-27.2384-5.0176-41.8816-16.2816L10.535936 469.2992A33.1776 33.1776 0 0 1 0.039936 445.2352V171.9296c-0.512-17.1008 3.8912-32.7168 13.824-45.568C25.639936 111.2064 43.457536 103.6288 66.548736 102.4h282.5216zM229.927936 237.9776c-45.056 0-81.5616 35.6352-81.5616 79.616 0 43.9296 36.5056 79.5648 81.5616 79.5648s81.5616-35.6352 81.5616-79.5648c0-43.9808-36.5056-79.616-81.5616-79.616z" fill="#14181F" p-id="25734"></path></svg>',
  ["embed"]: '<svg  viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" ><path d="M122.368 165.888h778.24c-9.216 0-16.384-7.168-16.384-16.384v713.728c0-9.216 7.168-16.384 16.384-16.384h-778.24c9.216 0 16.384 7.168 16.384 16.384V150.016c0 8.192-6.656 15.872-16.384 15.872z m-32.768 684.544c0 26.112 20.992 47.104 47.104 47.104h750.08c26.112 0 47.104-20.992 47.104-47.104V162.304c0-26.112-20.992-47.104-47.104-47.104H136.704c-26.112 0-47.104 20.992-47.104 47.104v688.128z" p-id="27999" fill="#14181F"></path><path d="M597.504 300.544h230.912v49.152h-230.912zM596.992 437.76h230.912v49.152h-230.912zM210.432 574.976h617.984v49.152H210.432zM210.432 712.192h617.984v49.152H210.432zM246.784 296.448h88.064V501.76h-29.184v29.184h117.248V501.76h-29.696V296.448H481.28v29.184h29.184V238.08H217.6v87.552h29.184z" p-id="28000" fill="#14181F"></path></svg>'
};
var TEXT_MAP = {
  ["text"]: "Text",
  ["heading1"]: "Heading1",
  ["heading2"]: "Heading2",
  ["heading3"]: "Heading3",
  ["heading4"]: "Heading4",
  ["heading5"]: "Heading5",
  ["heading6"]: "Heading6",
  ["todoList"]: "To-do List",
  ["bulletList"]: "Bulleted List",
  ["numberList"]: "Numbered List",
  ["code"]: "Code",
  ["quote"]: "Quote",
  ["linkBookMark"]: "Link Bookmark",
  ["divide"]: "Divide",
  ["noteCallout"]: "Note Callout",
  ["abstractCallout"]: "Abstract Callout",
  ["infoCallout"]: "Info Callout",
  ["todoCallout"]: "Todo Callout",
  ["tipCallout"]: "Tip Callout",
  ["successCallout"]: "Success Callout",
  ["questionCallout"]: "Question Callout",
  ["warningCallout"]: "Warning Callout",
  ["failureCallout"]: "Failure Callout",
  ["dangerCallout"]: "Danger Callout",
  ["bugCallout"]: "Bug Callout",
  ["exampleCallout"]: "example Callout"
};
var CONTENT_MAP = {
  embed: "![[]]",
  noteCallout: "> [!NOTE]\n> ",
  abstractCallout: "> [!abstract]\n> ",
  infoCallout: "> [!info]\n> ",
  todoCallout: "> [!todo]\n> ",
  tipCallout: "> [!tip]\n> ",
  successCallout: "> [!success]\n> ",
  questionCallout: "> [!question]\n> ",
  warningCallout: "> [!warning]\n> ",
  failureCallout: "> [!failure]\n> ",
  dangerCallout: "> [!danger]\n> ",
  bugCallout: "> [!bug]\n> ",
  exampleCallout: "> [!example]\n> ",
  quote: "> ",
  linkBookMark: "bookmark",
  math: "$$\n\n$$",
  text: "",
  heading1: "# ",
  heading2: "## ",
  heading3: "### ",
  heading4: "#### ",
  heading5: "##### ",
  heading6: "###### ",
  todoList: "- [ ] ",
  bulletList: "- ",
  numberList: "1. ",
  divide: "***\n",
  code: "```\n\n```"
};
var HEADING_MENU = [
  "insert-text",
  "insert-note-callout",
  "insert-abstract-callout",
  "insert-info-callout",
  "insert-todo-callout",
  "insert-tip-callout",
  "insert-success-callout",
  "insert-question-callout",
  "insert-warning-callout",
  "insert-failure-callout",
  "insert-danger-callout",
  "insert-bug-callout",
  "insert-example-callout",
  "insert-heading1",
  "insert-heading2",
  "insert-heading3",
  "insert-heading4",
  "insert-heading5",
  "insert-heading6",
  "insert-tag",
  "insert-math",
  "insert-quote",
  "insert-embed",
  "bookmark",
  "insert-todo",
  "insert-bulletList",
  "insert-numberList",
  "insert-code",
  "insert-divide"
];
var HEADING_CMDS = [
  "set-text",
  "set-heading1",
  "set-heading2",
  "set-heading3",
  "set-heading4",
  "set-heading5",
  "set-heading6",
  "set-todo",
  "set-bulletList",
  "set-numberList"
];
var SELECTION_CMDS = [
  "heading",
  "set-link",
  "toggle-bold",
  "toggle-strikethrough",
  "toggle-italics",
  "toggle-underline",
  "toggle-code",
  "toggle-math",
  "toggle-highlight"
];
var CMD_CONFIG = {
  ["insert-note-callout"]: {
    title: "Note Callout",
    icon: "note-call-out",
    cmd: "typing-assistant:insert-note-callout"
  },
  ["insert-abstract-callout"]: {
    title: "Abstract Callout",
    icon: "abstract-call-out",
    cmd: "typing-assistant:insert-abstract-callout"
  },
  ["insert-info-callout"]: {
    title: "Info Callout",
    icon: "info-call-out",
    cmd: "typing-assistant:insert-info-callout"
  },
  ["insert-todo-callout"]: {
    title: "Todo Callout",
    icon: "todo-call-out",
    cmd: "typing-assistant:insert-todo-callout"
  },
  ["insert-tip-callout"]: {
    title: "Tip Callout",
    icon: "tip-call-out",
    cmd: "typing-assistant:insert-tip-callout"
  },
  ["insert-success-callout"]: {
    title: "Success Callout",
    icon: "success-call-out",
    cmd: "typing-assistant:insert-success-callout"
  },
  ["insert-question-callout"]: {
    title: "Question Callout",
    icon: "question-call-out",
    cmd: "typing-assistant:insert-question-callout"
  },
  ["insert-warning-callout"]: {
    title: "Warning Callout",
    icon: "warning-call-out",
    cmd: "typing-assistant:insert-warning-callout"
  },
  ["insert-failure-callout"]: {
    title: "Failure Callout",
    icon: "failure-call-out",
    cmd: "typing-assistant:insert-failure-callout"
  },
  ["insert-danger-callout"]: {
    title: "Danger Callout",
    icon: "danger-call-out",
    cmd: "typing-assistant:insert-danger-callout"
  },
  ["insert-bug-callout"]: {
    title: "Bug Callout",
    icon: "bug-call-out",
    cmd: "typing-assistant:insert-bug-callout"
  },
  ["insert-example-callout"]: {
    title: "Example Callout",
    icon: "example-call-out",
    cmd: "typing-assistant:insert-example-callout"
  },
  "insert-tag": {
    title: "Tag",
    icon: "tag",
    cmd: "typing-assistant:insert-tag"
  },
  "insert-quote": {
    title: "Quote",
    icon: "quote",
    cmd: "typing-assistant:insert-quote"
  },
  "insert-math": {
    title: "Math Block",
    icon: "math",
    cmd: "typing-assistant:insert-mathblock"
  },
  "insert-embed": {
    title: "Embed",
    icon: "embed",
    cmd: "typing-assistant:insert-embed"
  },
  "insert-text": {
    title: "Text",
    icon: "text",
    cmd: "typing-assistant:insert-text"
  },
  "insert-heading1": {
    title: "Heading1",
    icon: "heading1",
    cmd: "typing-assistant:insert-heading1"
  },
  "insert-heading2": {
    title: "Heading2",
    icon: "heading2",
    cmd: "typing-assistant:insert-heading2"
  },
  "insert-heading3": {
    title: "Heading3",
    icon: "heading3",
    cmd: "typing-assistant:insert-heading3"
  },
  "insert-heading4": {
    title: "Heading4",
    icon: "heading4",
    cmd: "typing-assistant:insert-heading4"
  },
  "insert-heading5": {
    title: "Heading5",
    icon: "heading5",
    cmd: "typing-assistant:insert-heading5"
  },
  "insert-heading6": {
    title: "Heading6",
    icon: "heading6",
    cmd: "typing-assistant:insert-heading6"
  },
  "insert-todo": {
    title: "To-do List",
    icon: "todoList",
    cmd: "typing-assistant:insert-todo"
  },
  "insert-bulletList": {
    title: "BulletList",
    icon: "bulletList",
    cmd: "typing-assistant:insert-bulletList"
  },
  "insert-numberList": {
    title: "NumberList",
    icon: "numberList",
    cmd: "typing-assistant:insert-numberList"
  },
  "insert-divide": {
    title: "Divide",
    icon: "divide",
    cmd: "typing-assistant:insert-divide"
  },
  "insert-code": {
    title: "Code",
    icon: "code",
    cmd: "typing-assistant:insert-codeblock"
  },
  "toggle-math": {
    title: "Math",
    icon: "math",
    cmd: "editor:toggle-inline-math"
  },
  "toggle-highlight": {
    title: "Highlight",
    icon: "highlight",
    cmd: "editor:toggle-highlight"
  },
  "bookmark": {
    title: "Link BookMark",
    icon: "link",
    cmd: "bookmark"
  },
  "set-text": {
    title: "Text",
    icon: "text",
    cmd: "editor:set-heading-0"
  },
  "set-heading1": {
    title: "Heading1",
    icon: "heading1",
    cmd: "editor:set-heading-1"
  },
  "set-heading2": {
    title: "Heading2",
    icon: "heading2",
    cmd: "editor:set-heading-2"
  },
  "set-heading3": {
    title: "Heading3",
    icon: "heading3",
    cmd: "editor:set-heading-3"
  },
  "set-heading4": {
    title: "Heading4",
    icon: "heading4",
    cmd: "editor:set-heading-4"
  },
  "set-heading5": {
    title: "Heading5",
    icon: "heading5",
    cmd: "editor:set-heading-5"
  },
  "set-heading6": {
    title: "Heading6",
    icon: "heading6",
    cmd: "editor:set-heading-6"
  },
  "set-todo": {
    title: "To-do List",
    icon: "todoList",
    cmd: "typing-assistant:todo-list"
  },
  "set-bulletList": {
    title: "BulletList",
    icon: "bulletList",
    cmd: "editor:toggle-bullet-list"
  },
  "set-numberList": {
    title: "NumberList",
    icon: "numberList",
    cmd: "editor:toggle-numbered-list"
  },
  "set-link": {
    title: "Link",
    icon: "link",
    cmd: "editor:insert-link"
  },
  "toggle-bold": {
    title: "Bold",
    icon: "bold",
    cmd: "editor:toggle-bold"
  },
  "toggle-strikethrough": {
    title: "Strikethrough",
    icon: "strikethrough",
    cmd: "editor:toggle-strikethrough"
  },
  "toggle-italics": {
    title: "Italics",
    icon: "italics",
    cmd: "editor:toggle-italics"
  },
  "toggle-underline": {
    title: "Underline",
    icon: "underline",
    cmd: "typing-assistant:underline"
  },
  "toggle-code": {
    title: "Code",
    icon: "code",
    cmd: "editor:toggle-code"
  }
};
var CODE_LAN = "link-bookmark";
var MENU_WIDTH = 300;
var MAX_MENU_HEIGHT = 400;
var COMMAD_ITEM_EIGHT = 46;
var MENU_MARGIN = 6;
var VALID_URL_REG = /^(http|https):\/\/[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(:[0-9]{1,5})?(\/.*)?$/;

// src/components/command-menu.ts
var CommandMenu = class {
  constructor(props) {
    this.display = function() {
      var _a, _b;
      const range = (_a = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a.getRangeAt(0);
      const rect = range == null ? void 0 : range.getBoundingClientRect();
      const scroll = this.scrollArea.getBoundingClientRect();
      if (!rect)
        return;
      let { height, top, left } = rect;
      top += height + this.scrollArea.scrollTop;
      top -= scroll.top;
      left -= scroll.left;
      const rightDis = left + MENU_WIDTH - scroll.width;
      if (rightDis > 0) {
        left -= rightDis;
      }
      const upDis = top + this.menuHieght + MENU_MARGIN - this.scrollArea.scrollTop - this.scrollArea.clientHeight;
      if (upDis > 0) {
        this.scrollArea.scrollTo(0, this.scrollArea.scrollTop + upDis);
      }
      this.menu.style = `top:${top}px;left:${left}px`;
      if (!this.isVisible()) {
        this.menu.removeClass("display-none");
      }
      this.menu.children[0].focus();
      (_b = this.scrollArea) == null ? void 0 : _b.addClass("scroll-disable");
    };
    this.hide = function() {
      var _a;
      this.menu.addClass("display-none");
      (_a = this.scrollArea) == null ? void 0 : _a.removeClass("scroll-disable");
    };
    this.isVisible = function() {
      return !this.menu.hasClass("display-none");
    };
    this.remove = function() {
      this.scrollArea.removeChild(this.menu);
    };
    this.menu = createDiv({ cls: "command", attr: { id: "command-menu" } });
    this.mouseMoved = false;
    this.scrollArea = props.scrollArea;
    this.menuHieght = Math.min(COMMAD_ITEM_EIGHT * props.cmds.length, MAX_MENU_HEIGHT);
    props.cmds.forEach((item, idx) => {
      const btn = createDiv({
        parent: this.menu,
        cls: "command-option",
        attr: { tabindex: -1, commandType: item }
      });
      const IconDiv = createDiv({ parent: btn });
      (0, import_obsidian.setIcon)(IconDiv, CMD_CONFIG[item].icon);
      btn.createSpan({ text: CMD_CONFIG[item].title });
      btn.onclick = function() {
        props.onMenu(item);
      };
      btn.onmouseenter = function() {
        if (_this.mouseMoved) {
          btn.focus();
        }
        _this.mouseMoved = false;
      };
    });
    const _this = this;
    this.menu.onmousemove = function(e) {
      _this.mouseMoved = true;
    };
    this.menu.onkeydown = function(e) {
      const { key } = e;
      if (key === "ArrowUp" || key === "ArrowDown" || key === "ArrowLeft" || key === "ArrowRight" || key === "Enter") {
        const focusEle = document.activeElement;
        const cmd = focusEle == null ? void 0 : focusEle.getAttribute("commandType");
        if (!cmd)
          return;
        e == null ? void 0 : e.preventDefault();
        e == null ? void 0 : e.stopPropagation();
        if (key === "Enter") {
          props.onMenu(cmd);
          _this.hide();
        }
        let nextFocusEle = focusEle;
        if (key === "ArrowUp" || key === "ArrowLeft") {
          nextFocusEle = focusEle == null ? void 0 : focusEle.previousElementSibling;
          if (!nextFocusEle) {
            nextFocusEle = this == null ? void 0 : this.lastElementChild;
          }
        } else if (key === "ArrowDown" || key === "ArrowRight") {
          nextFocusEle = focusEle == null ? void 0 : focusEle.nextElementSibling;
          if (!nextFocusEle) {
            nextFocusEle = this == null ? void 0 : this.firstElementChild;
          }
        }
        nextFocusEle == null ? void 0 : nextFocusEle.focus();
      }
    };
    this.scrollArea.appendChild(this.menu);
    this.hide();
  }
};

// src/components/link-input-modal.ts
var import_obsidian2 = require("obsidian");
var InsertLinkModal = class extends import_obsidian2.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.checkUrl = (0, import_obsidian2.debounce)((url) => {
      if (VALID_URL_REG.test(url)) {
        this.close();
        this.onSubmit(url);
      } else {
        new import_obsidian2.Notice("Please input a valid url");
      }
    }, 10);
    this.onSubmit = onSubmit;
    this.isOpen = false;
  }
  onOpen() {
    this.isOpen = true;
    const { contentEl } = this;
    this.linkUrl = "";
    contentEl.createEl("h1", { text: "Insert a link bookmark" });
    new import_obsidian2.Setting(contentEl).setName("Link URL").addText(
      (text) => text.setValue(this.linkUrl).onChange((value) => {
        this.linkUrl = value;
      })
    ).setClass("link-input");
    new import_obsidian2.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Insert").setCta().onClick(() => {
        this.checkUrl(this.linkUrl);
      })
    );
    this.containerEl.addEventListener("keydown", (evt) => {
      if (evt.key === "Enter") {
        this.checkUrl(this.linkUrl);
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.isOpen = false;
  }
};

// src/components/selection-menu.ts
var import_obsidian3 = require("obsidian");
var SelectionBtns = class {
  constructor(props) {
    this.display = function(lineStyleText) {
      var _a;
      const range = (_a = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a.getRangeAt(0);
      const rect = range == null ? void 0 : range.getBoundingClientRect();
      const scroll = this.scrollArea.getBoundingClientRect();
      if (!rect)
        return;
      let { height, top, left } = rect;
      top += MENU_MARGIN + height + this.scrollArea.scrollTop - scroll.top;
      left -= scroll.left;
      const upDis = top + 56 - this.scrollArea.scrollTop - this.scrollArea.clientHeight;
      if (upDis > 0) {
        this.scrollArea.scrollTo(0, this.scrollArea.scrollTop + upDis);
      }
      const rightDis = left + MENU_WIDTH - this.scrollArea.clientWidth;
      if (rightDis > 0) {
        left -= rightDis;
      }
      this.menu.firstElementChild.firstElementChild.textContent = lineStyleText;
      if (top < this.headerHeight + 16) {
        top = -999;
      }
      this.menu.style = `top:${top}px;left:${left}px`;
      this.menu.removeClass("display-none");
      this.menu.children[0].focus();
    };
    this.hide = function() {
      this.menu.addClass("display-none");
      this.hideHeading();
    };
    this.showHeading = function() {
      var _a;
      const rect = (_a = this.menu) == null ? void 0 : _a.getBoundingClientRect();
      const contentRect = this.scrollArea.getBoundingClientRect();
      const topOffset = rect.top + rect.height + 430 - this.scrollArea.clientHeight - contentRect.top + MENU_MARGIN;
      const containerTopBorder = topOffset <= 0 ? 36 : 36 - topOffset;
      this.lineMenu.style = `top:${containerTopBorder}px`;
    };
    this.hideHeading = function() {
      this.lineMenu.style = "display:none";
    };
    this.isVisible = function() {
      return !!document.querySelector(".selection");
    };
    this.remove = function() {
      this.scrollArea.removeChild(this.menu);
    };
    this.menu = createDiv({
      cls: "selection",
      attr: { id: "selection-menu" }
    });
    this.scrollArea = props.scrollArea;
    this.headerHeight = props.headerHeight;
    const _this = this;
    const menu_content = createDiv({ cls: "selection-content" });
    SELECTION_CMDS.forEach((item, idx) => {
      const btn = createDiv({
        cls: "selection-btn",
        attr: { commandType: idx }
      });
      if (idx === 0) {
        btn.createSpan(TEXT_MAP["text"]);
      } else {
        (0, import_obsidian3.setIcon)(btn, CMD_CONFIG[item].icon);
      }
      btn.onclick = function(e) {
        if (idx === 0) {
          e.preventDefault();
          e.stopPropagation();
          _this.showHeading();
        } else {
          props.onAction(item, false);
        }
      };
      menu_content.appendChild(btn);
    });
    this.menu.appendChild(menu_content);
    this.lineMenu = createDiv({ cls: "linemenu" });
    this.hideHeading();
    HEADING_CMDS.forEach((item, idx) => {
      const btn = createDiv({
        cls: "linemenu-option",
        attr: { commandType: idx }
      });
      const IconDiv = createDiv({
        parent: btn,
        cls: "linemenu-option-svg"
      });
      (0, import_obsidian3.setIcon)(IconDiv, CMD_CONFIG[item].icon);
      btn.createSpan({ text: CMD_CONFIG[item].title });
      btn.onclick = function() {
        props.onAction(item, true);
      };
      this.lineMenu.appendChild(btn);
    });
    this.menu.appendChild(this.lineMenu);
    this.scrollArea.appendChild(this.menu);
    this.hide();
  }
};

// src/components/plugin-setting.ts
var import_obsidian4 = require("obsidian");

// node_modules/sortablejs/modular/sortable.esm.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.1";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top,
    left,
    bottom,
    right,
    width,
    height
  };
}
function getContentRect(el) {
  var rect = getRect(el);
  var paddingLeft = parseInt(css(el, "padding-left")), paddingTop = parseInt(css(el, "padding-top")), paddingRight = parseInt(css(el, "padding-right")), paddingBottom = parseInt(css(el, "padding-bottom"));
  rect.top += paddingTop + parseInt(css(el, "border-top-width"));
  rect.left += paddingLeft + parseInt(css(el, "border-left-width"));
  rect.width = el.clientWidth - paddingLeft - paddingRight;
  rect.height = el.clientHeight - paddingTop - paddingBottom;
  rect.bottom = rect.top + rect.height;
  rect.right = rect.left + rect.width;
  return rect;
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i = 0, children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key])
        return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault)
        return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl;
var parentEl;
var ghostEl;
var rootEl;
var nextEl;
var lastDownEl;
var cloneEl;
var cloneHidden;
var oldIndex;
var newIndex;
var oldDraggableIndex;
var newDraggableIndex;
var activeGroup;
var putSortable;
var awaitingDragStarted = false;
var ignoreNextClick = false;
var sortables = [];
var tapEvt;
var touchEvt;
var lastDx;
var lastDy;
var tapDistanceLeft;
var tapDistanceTop;
var moved;
var lastTarget;
var lastDirection;
var pastFirstInvertThresh = false;
var isCircumstantialInvert = false;
var targetMoveDistance;
var ghostRelativeParent;
var ghostRelativeParentInitialScroll = [];
var _silent = false;
var savedInputChecked = [];
var documentExists = typeof document !== "undefined";
var PositionGhostAbsolutely = IOS;
var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
var supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}();
var _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
};
var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
};
var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
};
var _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
};
var _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
};
var _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name in defaults2) {
    !(name in options) && (options[name] = defaults2[name]);
  }
  _prepareGroup(options);
  for (var fn in this) {
    if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
      this[fn] = this[fn].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on(el, "pointerdown", this._onTapStart);
  } else {
    on(el, "mousedown", this._onTapStart);
    on(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, "dragover", this);
    on(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mouseup", _this._onDrop);
      on(ownerDocument, "touchend", _this._onDrop);
      on(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on(ownerDocument, "touchend", _this._disableDelayedDrag);
        on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent)
          break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [], el, children = this.el.children, i = 0, n = children.length, options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i) {
      var el = rootEl2.children[i];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== "undefined") {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === "group") {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var sortableContentRect = getContentRect(sortable.el);
  var spacer = 10;
  return vertical ? evt.clientX < sortableContentRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < sortableContentRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var sortableContentRect = getContentRect(sortable.el);
  var spacer = 10;
  return vertical ? evt.clientX > sortableContentRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > sortableContentRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone,
  index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version;
var autoScrolls = [];
var scrollEl;
var scrollRootEl;
var scrolling = false;
var lastAutoScrollX;
var lastAutoScrollY;
var touchEvt$1;
var pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll)
    return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
var sortable_esm_default = Sortable;

// src/components/plugin-setting.ts
var ExampleSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    var _a;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Typing Assistant" });
    containerEl.createEl("p", { text: "For any questions or suggestions during use, please feel free to " }).createEl("a", {
      text: "contact me",
      href: "https://github.com/Jambo2018/notion-assistant-plugin"
    });
    new import_obsidian4.Setting(containerEl).setName("Typing Placeholder").setDesc('Show "\u{1F4A1}Please input \u2018 / \u2019 for more commands..." prompt when typing on a blank line').addToggle(
      (component) => component.setValue(this.plugin.settings.showPlaceholder).onChange(async (value) => {
        this.plugin.settings.showPlaceholder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Commands Menu").setDesc("Supports custom command combinations and drag-and-drop sorting; please ensure that at least 5 commands are open");
    const CmdSettings = containerEl.createDiv({ cls: "heading-config" });
    const CmdsOn = containerEl.createDiv({ attr: { id: "cmds-on" }, cls: "heading-config-on" });
    const CmdsOff = containerEl.createDiv({ attr: { id: "cmds-off" }, cls: "heading-config-off" });
    CmdSettings.appendChild(CmdsOn);
    CmdSettings.appendChild(CmdsOff);
    let cmdsSorting = ((_a = this.plugin.settings) == null ? void 0 : _a.cmdsSorting) || [];
    const cmdsAll = [.../* @__PURE__ */ new Set([...cmdsSorting, ...HEADING_MENU])];
    for (let i = 0; i < cmdsAll.length; i++) {
      const cmd = cmdsAll[i];
      let HeaderItem;
      const isChecked = this.plugin.settings.cmdsSorting.includes(cmd);
      if (isChecked) {
        HeaderItem = CmdsOn.createDiv({ cls: "heading-item" });
      } else {
        HeaderItem = CmdsOff.createDiv({ cls: "heading-item" });
      }
      const IconDiv = HeaderItem.createDiv({ cls: "heading-item-icon" });
      (0, import_obsidian4.setIcon)(IconDiv, CMD_CONFIG[cmd].icon);
      new import_obsidian4.Setting(HeaderItem).setName(CMD_CONFIG[cmd].title).addToggle(
        (component) => component.setValue(isChecked).onChange(async () => {
          if (cmdsSorting.includes(cmd)) {
            cmdsSorting = cmdsSorting.filter((i2) => i2 !== cmd);
            CmdsOn.removeChild(HeaderItem);
            CmdsOff.insertBefore(HeaderItem, CmdsOff.firstElementChild);
          } else {
            cmdsSorting.push(cmd);
            CmdsOff.removeChild(HeaderItem);
            CmdsOn.appendChild(HeaderItem);
          }
          this.hasChanged = true;
          this.plugin.settings.cmdsSorting = [...cmdsSorting];
          await this.plugin.saveSettings();
        })
      ).setDisabled(cmdsSorting.length <= 5 && cmdsSorting.includes(cmd));
    }
    new sortable_esm_default(CmdsOn, {
      onEnd: async (e) => {
        const cmdsSorting2 = Array.from(e.to.children).map((item) => {
          return HEADING_MENU.find((cmd) => CMD_CONFIG[cmd].title === item.textContent);
        });
        this.plugin.settings.cmdsSorting = [...cmdsSorting2];
        this.hasChanged = true;
        await this.plugin.saveSettings();
      }
    });
  }
  hide() {
    if (this.hasChanged) {
      this.app.commands.executeCommandById("app:reload");
    }
  }
};

// src/util/util.ts
var import_obsidian6 = require("obsidian");

// src/util/cmd-generate.ts
var import_obsidian5 = require("obsidian");
function loadCommands() {
  const formatUnderline = (editor, line, left, right) => {
    const selectedRange = [
      { line, ch: left },
      { line, ch: right }
    ];
    let selection = editor.getRange(...selectedRange);
    if (/((?!u>).*?)((<u>(?!u>).*<\/u>)+)((?!u>).*?)/.test(selection)) {
      selection = selection.replace(/<\/?u>/g, "");
    }
    editor.replaceRange(`<u>${selection}</u>`, ...selectedRange);
    const content = editor.getLine(line);
    const arr = content.split(/<\/?u>/g);
    let joinContent = "";
    arr.forEach((item, index2) => {
      if (index2 % 2 === 0) {
        joinContent += item != null ? item : "";
        if (index2 < arr.length - 1) {
          joinContent += "<u>";
        }
      } else {
        joinContent += (item != null ? item : "") + "</u>";
      }
    });
    joinContent = joinContent.replace(/(<\/u><u>)|(<u><\/u>)/g, "");
    editor.setLine(line, joinContent);
  };
  const generateCommand = (content) => {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (view) {
      const cursor = view.editor.getCursor();
      const editLine = view.editor.getLine(cursor.line);
      if (editLine.length > 1) {
        view.editor.replaceRange(
          `
${content}`,
          { line: cursor.line, ch: cursor.ch - 1 },
          cursor
        );
        view.editor.setCursor({
          line: cursor.line + 1,
          ch: content.length
        });
      } else {
        view.editor.setLine(cursor.line, content);
        view.editor.setCursor({
          line: cursor.line,
          ch: content.length
        });
      }
      view.editor.focus();
    }
  };
  this.addCommand({
    id: "insert-text",
    name: "Insert normal text",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["text"]);
    }
  });
  this.addCommand({
    id: "insert-heading1",
    name: "Insert Heading-1",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["heading1"]);
    }
  });
  this.addCommand({
    id: "insert-heading2",
    name: "Insert Heading-2",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["heading2"]);
    }
  });
  this.addCommand({
    id: "insert-heading3",
    name: "Insert Heading-3",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["heading3"]);
    }
  });
  this.addCommand({
    id: "insert-heading4",
    name: "Insert Heading-4",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["heading4"]);
    }
  });
  this.addCommand({
    id: "insert-heading5",
    name: "Insert Heading-5",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["heading5"]);
    }
  });
  this.addCommand({
    id: "insert-heading6",
    name: "Insert Heading-6",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["heading6"]);
    }
  });
  this.addCommand({
    id: "insert-todo",
    name: "Insert TodoList",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["todoList"]);
    }
  });
  this.addCommand({
    id: "insert-bulletList",
    name: "Insert BulletList",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["bulletList"]);
    }
  });
  this.addCommand({
    id: "insert-numberList",
    name: "Insert NumberList",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["numberList"]);
    }
  });
  this.addCommand({
    id: "insert-divide",
    name: "Insert Divide",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["divide"]);
    }
  });
  this.addCommand({
    id: "insert-quote",
    name: "Insert Quote",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["quote"]);
    }
  });
  this.addCommand({
    id: "insert-note-callout",
    name: "Insert Callout",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["noteCallout"]);
    }
  });
  this.addCommand({
    id: "insert-abstract-callout",
    name: "Insert Callout",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["abstractCallout"]);
    }
  });
  this.addCommand({
    id: "insert-info-callout",
    name: "Insert Callout",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["infoCallout"]);
    }
  });
  this.addCommand({
    id: "insert-todo-callout",
    name: "Insert Callout",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["todoCallout"]);
    }
  });
  this.addCommand({
    id: "insert-tip-callout",
    name: "Insert Callout",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["tipCallout"]);
    }
  });
  this.addCommand({
    id: "insert-success-callout",
    name: "Success Callout",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["successCallout"]);
    }
  });
  this.addCommand({
    id: "insert-question-callout",
    name: "Question Callout",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["questionCallout"]);
    }
  });
  this.addCommand({
    id: "insert-warning-callout",
    name: "Warning Callout",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["warningCallout"]);
    }
  });
  this.addCommand({
    id: "insert-failure-callout",
    name: "Failure Callout",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["failureCallout"]);
    }
  });
  this.addCommand({
    id: "insert-danger-callout",
    name: "Danger Callout",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["dangerCallout"]);
    }
  });
  this.addCommand({
    id: "insert-bug-callout",
    name: "Bug Callout",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["bugCallout"]);
    }
  });
  this.addCommand({
    id: "insert-example-callout",
    name: "Example Callout",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["exampleCallout"]);
    }
  });
  this.addCommand({
    id: "insert-mathblock",
    name: "Insert Math Block",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["math"]);
      CONTENT_MAP["code"];
      const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
      if (view) {
        const cursor = view.editor.getCursor();
        const editLine = view.editor.getLine(cursor.line);
        view.editor.setCursor(cursor.line - 1);
        view.editor.focus();
      }
    }
  });
  this.addCommand({
    id: "insert-codeblock",
    name: "Insert Math Block",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["code"]);
      const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
      if (view) {
        const cursor = view.editor.getCursor();
        const editLine = view.editor.getLine(cursor.line);
        view.editor.setCursor(cursor.line - 1);
        view.editor.focus();
      }
    }
  });
  this.addCommand({
    id: "insert-tag",
    name: "Insert Tag",
    editorCallback: (editor) => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
      if (view) {
        const cursor = view.editor.getCursor();
        const editLine = view.editor.getLine(cursor.line);
        let content = editLine.length > 1 ? " #" : "#";
        view.editor.replaceRange(
          content,
          { line: cursor.line, ch: cursor.ch - 1 },
          cursor
        );
        view.editor.focus();
      }
    }
  });
  this.addCommand({
    id: "insert-embed",
    name: "Insert Embed",
    editorCallback: (editor) => {
      generateCommand(CONTENT_MAP["embed"]);
      const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
      if (view) {
        const cursor = view.editor.getCursor();
        view.editor.setCursor({ ...cursor, ch: cursor.ch - 2 });
        view.editor.focus();
      }
    }
  });
  this.addCommand({
    id: "underline",
    name: "Underline/Cancel underline",
    editorCallback: (editor) => {
      const from = editor.getCursor("from");
      const to = editor.getCursor("to");
      for (let i = from.line; i <= to.line; i++) {
        const len = editor.getLine(i).length;
        if (from.line === to.line) {
          formatUnderline(editor, i, from.ch, to.ch);
        } else if (i === from.line && i < to.line) {
          formatUnderline(editor, i, from.ch, len);
        } else if (i > from.line && i < to.line) {
          formatUnderline(editor, i, 0, len);
        } else if (i > from.line && i === to.line) {
          formatUnderline(editor, i, 0, to.ch);
        }
      }
    }
  });
  this.addCommand({
    id: "todo-list",
    name: "Add TodoList",
    editorCallback: (editor) => {
      const { line, ch } = editor.getCursor();
      const content = editor.getLine(line);
      if (content.startsWith("[ ] ")) {
        editor.replaceRange("", { line, ch: 0 }, { line, ch: 4 });
      } else {
        editor.replaceRange(
          `- [ ] `,
          { line, ch: 0 },
          { line, ch: 0 }
        );
      }
    }
  });
}

// src/util/link-bookmark.ts
var generateBookMark = (content) => {
  var _a;
  const obj = {};
  ((_a = content.split("\n")) != null ? _a : []).forEach((item) => {
    var _a2;
    const [str, key, value = ""] = (_a2 = item.match(/([^:]+):(.*)/)) != null ? _a2 : [];
    obj[key] = value;
  });
  const linkDiv = createDiv();
  linkDiv.setAttribute("class", "ta-bookmark");
  linkDiv.onclick = () => {
    window.open(obj.url);
  };
  const contentDiv = createDiv({ parent: linkDiv, cls: "ta-bookmark-content" });
  if (obj.title) {
    contentDiv.createDiv({ cls: "ta-bookmark-title", text: obj.title });
  }
  if (obj.description) {
    contentDiv.createDiv({
      cls: "ta-bookmark-description",
      text: obj.description
    });
  }
  const urlDiv = contentDiv.createDiv({ cls: "ta-bookmark-url" });
  if (obj.logo) {
    urlDiv.createDiv({
      cls: "ta-bookmark-url-logo",
      attr: { style: `background-image: url('${obj.logo}')` }
    });
  }
  urlDiv.createSpan({ cls: "ta-bookmark-url-text", text: obj.url });
  if (obj.coverImg) {
    linkDiv.createDiv({ cls: "ta-bookmark-cover", attr: { style: `background-image: url('${obj.coverImg}')` } });
  }
  return linkDiv;
};

// src/util/util.ts
var handleUrlPrefix = (link, url) => {
  if (/^\/\//.test(url)) {
    url = link.split(":")[0] + ":" + url;
  } else if (/^\/[^/]/.test(url)) {
    url = link.split("?")[0] + url;
  }
  return url;
};
var linkParse = async (link) => {
  var _a, _b, _c, _d;
  const result = { url: link };
  try {
    const html = await (0, import_obsidian6.request)(link);
    if (html) {
      let titleMatch = html.match(
        /<meta[^>]*title[^>]*content="(.*?)"[^>]*>/
      );
      if (!titleMatch || titleMatch.length <= 1) {
        titleMatch = html.match(/<title[^>]*>(.*?)<\/title>/);
      }
      result.title = (_a = titleMatch == null ? void 0 : titleMatch[1]) != null ? _a : "";
      const desMatch = html.match(
        /<meta[^>]*description[^>]*content="(.*?)"[^>]*>/
      );
      result.description = (_b = desMatch == null ? void 0 : desMatch[1]) != null ? _b : "";
      let imgMatch = html.match(
        /<meta[^>]*image[^>]*content="(.*?)"[^>]*>/
      );
      if (!imgMatch || imgMatch.length <= 1) {
        imgMatch = html.match(/<img[^>]*src="(.*?)"[^>]*>/);
      }
      result.coverImg = (_c = imgMatch == null ? void 0 : imgMatch[1]) != null ? _c : "";
      if (result.coverImg) {
        result.coverImg = handleUrlPrefix(link, result.coverImg);
      }
      const logoMatch = html.match(
        /<link[^>]*icon[^>]*href="([^"]*)"[^>]*>/
      );
      result.logo = (_d = logoMatch == null ? void 0 : logoMatch[1]) != null ? _d : "";
      if (result.logo) {
        result.logo = handleUrlPrefix(link, result.logo);
      }
    }
    return result;
  } catch (e) {
    console.warn("request link error:", e);
    return result;
  }
};
var loadIcons = (icons) => {
  for (const key in icons) {
    (0, import_obsidian6.addIcon)(key, icons[key]);
  }
};

// main.ts
var TypingAsstPlugin = class extends import_obsidian7.Plugin {
  async loadSettings() {
    const initialMenu = HEADING_MENU.filter((item) => item === "insert-note-callout" || !item.includes("callout"));
    this.settings = Object.assign({}, { showPlaceholder: true, cmdsSorting: initialMenu }, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async onload() {
    await this.loadSettings();
    loadCommands.call(this);
    this.addSettingTab(new ExampleSettingTab(this.app, this));
    loadIcons(ICON_MAP);
    const onSelectionAction = async (content, isHeading) => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
      if (!(view == null ? void 0 : view.editor))
        return;
      if (isHeading) {
        const editor = view.editor;
        const cursor = editor.getCursor();
        const lineContent = editor.getLine(cursor.line);
        editor.setLine(cursor.line, lineContent.replace(/^.*?\s/, ""));
      }
      this.app.commands.executeCommandById(CMD_CONFIG[content].cmd);
      if (content === "set-link") {
        view.editor.focus();
      }
      this.btns.hide();
    };
    const onMenuClick = async (content) => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
      if (view) {
        if (content === "bookmark") {
          view.editor.blur();
          this.linkModal.open();
        } else {
          this.app.commands.executeCommandById(
            CMD_CONFIG[content].cmd
          );
          view.editor.focus();
        }
      }
    };
    const onLinkSubmit = async (url) => {
      const parsedResult = await linkParse(url);
      let codeStr = "```" + CODE_LAN + "\n";
      for (const key in parsedResult) {
        codeStr += key + ":" + parsedResult[key] + "\n";
      }
      codeStr += "```\n";
      const view = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
      if (view) {
        const cursor = view.editor.getCursor();
        const editLine = view.editor.getLine(cursor.line);
        if (editLine.length > 0) {
          view.editor.replaceRange(
            `
${codeStr}`,
            { line: cursor.line, ch: cursor.ch - 1 },
            cursor
          );
          view.editor.setCursor({
            line: cursor.line + 1,
            ch: codeStr.length
          });
        } else {
          view.editor.setLine(cursor.line, codeStr);
          view.editor.setCursor({
            line: cursor.line,
            ch: codeStr.length
          });
        }
      }
    };
    const handleSelection = () => {
      var _a, _b;
      const selection = (_a = document.getSelection()) == null ? void 0 : _a.toString();
      if (selection) {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
        if (!(view == null ? void 0 : view.editor))
          return;
        const editor = view.editor;
        const cursor = editor.getCursor();
        const lineContent = editor.getLine(cursor.line);
        let lineStyle = "Text";
        for (const cmd in CONTENT_MAP) {
          if (cmd === "text") {
            continue;
          } else if (/^\`\`\`/.test(lineContent)) {
            lineStyle = TEXT_MAP["code"];
            break;
          } else if (lineContent.startsWith(CONTENT_MAP[cmd])) {
            lineStyle = TEXT_MAP[cmd];
            break;
          } else if (/^[\d]+\.\s/.test(lineContent)) {
            lineStyle = TEXT_MAP["numberList"];
            break;
          }
        }
        (_b = this.btns) == null ? void 0 : _b.display(lineStyle);
      }
    };
    this.linkModal = new InsertLinkModal(this.app, onLinkSubmit);
    this.registerDomEvent(document, "click", (evt) => {
      var _a, _b, _c;
      (_a = this.commands) == null ? void 0 : _a.hide();
      const selection = (_b = document.getSelection()) == null ? void 0 : _b.toString();
      if (!selection && ((_c = this.btns) == null ? void 0 : _c.isVisible())) {
        this.btns.hide();
      }
    });
    this.registerDomEvent(document, "mouseup", (evt) => {
      handleSelection();
    });
    this.registerDomEvent(document, "keydown", (evt) => {
      var _a, _b;
      renderEmptyText();
      if ((_a = this.commands) == null ? void 0 : _a.isVisible()) {
        const { key } = evt;
        if (key !== "ArrowUp" && key !== "ArrowDown" && key !== "ArrowLeft" && key !== "ArrowRight") {
          this.commands.hide();
          const view = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
          if (view) {
            view.editor.focus();
          }
        }
      }
      (_b = this.btns) == null ? void 0 : _b.hide();
    });
    const scrollEvent = () => {
      var _a;
      if ((_a = this.btns) == null ? void 0 : _a.isVisible()) {
      }
    };
    const renderPlugin = () => {
      var _a, _b, _c, _d, _e;
      if (this.scrollArea) {
        this.scrollArea.removeEventListener("scroll", scrollEvent);
      }
      const view = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
      if (!view)
        return;
      this.scrollArea = (_a = view.containerEl.querySelector(".cm-scroller")) != null ? _a : void 0;
      const appHeader = document.querySelector(".titlebar");
      const viewHeader = view.containerEl.querySelector(".view-header");
      const headerHeight = ((_b = appHeader == null ? void 0 : appHeader.clientHeight) != null ? _b : 0) + ((_c = viewHeader == null ? void 0 : viewHeader.clientHeight) != null ? _c : 0);
      if (!this.scrollArea)
        return;
      const scrollArea = this.scrollArea;
      (_d = this.commands) == null ? void 0 : _d.remove();
      this.commands = new CommandMenu({
        scrollArea,
        onMenu: onMenuClick,
        cmds: this.settings.cmdsSorting
      });
      (_e = this.btns) == null ? void 0 : _e.remove();
      this.btns = new SelectionBtns({
        scrollArea,
        headerHeight,
        onAction: onSelectionAction
      });
      scrollArea == null ? void 0 : scrollArea.addEventListener("scroll", scrollEvent);
    };
    renderPlugin();
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", renderPlugin)
    );
    this.registerDomEvent(document, "input", (evt) => {
      var _a, _b;
      if (this.linkModal.isOpen)
        return;
      if (evt && evt.data === "/") {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
        if (!view)
          return;
        const cursor = view.editor.getCursor();
        const editLine = view.editor.getLine(cursor.line);
        if (editLine.replace(/[\s]*$/, "").length <= cursor.ch) {
          (_a = this.commands) == null ? void 0 : _a.display();
        } else {
          (_b = this.commands) == null ? void 0 : _b.hide();
        }
      }
    });
    const renderEmptyText = () => {
      if (!this.settings.showPlaceholder)
        return;
      const view = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
      if (!view)
        return;
      setTimeout(() => {
        const activeEle = view.containerEl.querySelector(".cm-active");
        activeEle == null ? void 0 : activeEle.setAttribute(
          "promote-text",
          "\u{1F4A1}Please input \u2018 / \u2019 for more commands..."
        );
      }, 50);
    };
    this.registerDomEvent(document, "pointermove", () => {
      renderEmptyText();
    });
    this.registerDomEvent(document, "click", () => {
      renderEmptyText();
    });
    this.registerMarkdownCodeBlockProcessor(CODE_LAN, (source, el, ctx) => {
      const bookmark = generateBookMark(source);
      el == null ? void 0 : el.appendChild(bookmark);
    });
  }
  onunload() {
    var _a, _b;
    (_a = this.commands) == null ? void 0 : _a.remove();
    (_b = this.btns) == null ? void 0 : _b.remove();
  }
};
/*! Bundled license information:

sortablejs/modular/sortable.esm.js:
  (**!
   * Sortable 1.15.1
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)
*/
